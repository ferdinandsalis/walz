diff --git a/node_modules/@react-router/dev/dist/cli/index.js b/node_modules/@react-router/dev/dist/cli/index.js
index 266c57f..9432152 100644
--- a/node_modules/@react-router/dev/dist/cli/index.js
+++ b/node_modules/@react-router/dev/dist/cli/index.js
@@ -9,280 +9,297 @@
  *
  * @license MIT
  */
-"use strict";
-var __create = Object.create;
-var __defProp = Object.defineProperty;
-var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
-var __getOwnPropNames = Object.getOwnPropertyNames;
-var __getProtoOf = Object.getPrototypeOf;
-var __hasOwnProp = Object.prototype.hasOwnProperty;
-var __esm = (fn, res) => function __init() {
-  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
-};
+'use strict'
+var __create = Object.create
+var __defProp = Object.defineProperty
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor
+var __getOwnPropNames = Object.getOwnPropertyNames
+var __getProtoOf = Object.getPrototypeOf
+var __hasOwnProp = Object.prototype.hasOwnProperty
+var __esm = (fn, res) =>
+  function __init() {
+    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res
+  }
 var __export = (target, all) => {
   for (var name in all)
-    __defProp(target, name, { get: all[name], enumerable: true });
-};
+    __defProp(target, name, { get: all[name], enumerable: true })
+}
 var __copyProps = (to, from, except, desc) => {
-  if (from && typeof from === "object" || typeof from === "function") {
+  if ((from && typeof from === 'object') || typeof from === 'function') {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
-        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+        __defProp(to, key, {
+          get: () => from[key],
+          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
+        })
   }
-  return to;
-};
-var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  // If the importer is in node compatibility mode or this is not an ESM
-  // file that has been converted to a CommonJS file using a Babel-
-  // compatible transform (i.e. "__esModule" has not been set), then set
-  // "default" to the CommonJS "module.exports" for node compatibility.
-  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-  mod
-));
+  return to
+}
+var __toESM = (mod, isNodeMode, target) => (
+  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
+  __copyProps(
+    // If the importer is in node compatibility mode or this is not an ESM
+    // file that has been converted to a CommonJS file using a Babel-
+    // compatible transform (i.e. "__esModule" has not been set), then set
+    // "default" to the CommonJS "module.exports" for node compatibility.
+    isNodeMode || !mod || !mod.__esModule
+      ? __defProp(target, 'default', { value: mod, enumerable: true })
+      : target,
+    mod,
+  )
+)
 
 // invariant.ts
 function invariant(value, message) {
-  if (value === false || value === null || typeof value === "undefined") {
+  if (value === false || value === null || typeof value === 'undefined') {
     console.error(
-      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
-    );
-    throw new Error(message);
+      'The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose',
+    )
+    throw new Error(message)
   }
 }
 var init_invariant = __esm({
-  "invariant.ts"() {
-    "use strict";
-  }
-});
+  'invariant.ts'() {
+    'use strict'
+  },
+})
 
 // vite/import-vite-esm-sync.ts
 async function preloadViteEsm() {
-  vite = await import("vite");
+  vite = await import('vite')
 }
 function importViteEsmSync() {
-  invariant(vite, "importViteEsmSync() called before preloadViteEsm()");
-  return vite;
+  invariant(vite, 'importViteEsmSync() called before preloadViteEsm()')
+  return vite
 }
-var vite;
+var vite
 var init_import_vite_esm_sync = __esm({
-  "vite/import-vite-esm-sync.ts"() {
-    "use strict";
-    init_invariant();
-  }
-});
+  'vite/import-vite-esm-sync.ts'() {
+    'use strict'
+    init_invariant()
+  },
+})
 
 // vite/vite-node.ts
 async function createContext(viteConfig = {}) {
-  await preloadViteEsm();
-  const vite2 = importViteEsmSync();
+  await preloadViteEsm()
+  const vite2 = importViteEsmSync()
   const devServer = await vite2.createServer(
     vite2.mergeConfig(
       {
         server: {
           preTransformRequests: false,
-          hmr: false
+          hmr: false,
         },
         optimizeDeps: {
-          noDiscovery: true
+          noDiscovery: true,
         },
         configFile: false,
         envFile: false,
-        plugins: []
+        plugins: [],
       },
-      viteConfig
-    )
-  );
-  await devServer.pluginContainer.buildStart({});
-  const server = new import_server.ViteNodeServer(devServer);
-  (0, import_source_map.installSourcemapsSupport)({
-    getSourceMap: (source) => server.getSourceMap(source)
-  });
+      viteConfig,
+    ),
+  )
+  await devServer.pluginContainer.buildStart({})
+  const server = new import_server.ViteNodeServer(devServer)
+  ;(0, import_source_map.installSourcemapsSupport)({
+    getSourceMap: source => server.getSourceMap(source),
+  })
   const runner = new import_client.ViteNodeRunner({
     root: devServer.config.root,
     base: devServer.config.base,
     fetchModule(id2) {
-      return server.fetchModule(id2);
+      return server.fetchModule(id2)
     },
     resolveId(id2, importer) {
-      return server.resolveId(id2, importer);
-    }
-  });
-  return { devServer, server, runner };
+      return server.resolveId(id2, importer)
+    },
+  })
+  return { devServer, server, runner }
 }
-var import_server, import_client, import_source_map;
+var import_server, import_client, import_source_map
 var init_vite_node = __esm({
-  "vite/vite-node.ts"() {
-    "use strict";
-    import_server = require("vite-node/server");
-    import_client = require("vite-node/client");
-    import_source_map = require("vite-node/source-map");
-    init_import_vite_esm_sync();
-  }
-});
+  'vite/vite-node.ts'() {
+    'use strict'
+    import_server = require('vite-node/server')
+    import_client = require('vite-node/client')
+    import_source_map = require('vite-node/source-map')
+    init_import_vite_esm_sync()
+  },
+})
 
 // config/routes.ts
 function setAppDirectory(directory) {
-  globalThis.__reactRouterAppDirectory = directory;
+  globalThis.__reactRouterAppDirectory = directory
 }
-function validateRouteConfig({
-  routeConfigFile,
-  routeConfig
-}) {
+function validateRouteConfig({ routeConfigFile, routeConfig }) {
   if (!routeConfig) {
     return {
       valid: false,
-      message: `Route config must be the default export in "${routeConfigFile}".`
-    };
+      message: `Route config must be the default export in "${routeConfigFile}".`,
+    }
   }
   if (!Array.isArray(routeConfig)) {
     return {
       valid: false,
-      message: `Route config in "${routeConfigFile}" must be an array.`
-    };
+      message: `Route config in "${routeConfigFile}" must be an array.`,
+    }
   }
-  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
+  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig)
   if (issues?.length) {
-    let { root, nested } = v.flatten(issues);
+    let { root, nested } = v.flatten(issues)
     return {
       valid: false,
       message: [
         `Route config in "${routeConfigFile}" is invalid.`,
         root ? `${root}` : [],
-        nested ? Object.entries(nested).map(
-          ([path8, message]) => `Path: routes.${path8}
-${message}`
-        ) : []
-      ].flat().join("\n\n")
-    };
+        nested
+          ? Object.entries(nested).map(
+              ([path8, message]) => `Path: routes.${path8}
+${message}`,
+            )
+          : [],
+      ]
+        .flat()
+        .join('\n\n'),
+    }
   }
-  return { valid: true };
+  return { valid: true }
 }
-function configRoutesToRouteManifest(appDirectory, routes2, rootId = "root") {
-  let routeManifest = {};
+function configRoutesToRouteManifest(appDirectory, routes2, rootId = 'root') {
+  let routeManifest = {}
   function walk(route, parentId) {
-    let id2 = route.id || createRouteId(route.file);
+    let id2 = route.id || createRouteId(route.file)
     let manifestItem = {
       id: id2,
       parentId,
-      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
+      file: Path.isAbsolute(route.file)
+        ? Path.relative(appDirectory, route.file)
+        : route.file,
       path: route.path,
       index: route.index,
-      caseSensitive: route.caseSensitive
-    };
+      caseSensitive: route.caseSensitive,
+    }
     if (routeManifest.hasOwnProperty(id2)) {
       throw new Error(
-        `Unable to define routes with duplicate route id: "${id2}"`
-      );
+        `Unable to define routes with duplicate route id: "${id2}"`,
+      )
     }
-    routeManifest[id2] = manifestItem;
+    routeManifest[id2] = manifestItem
     if (route.children) {
       for (let child of route.children) {
-        walk(child, id2);
+        walk(child, id2)
       }
     }
   }
   for (let route of routes2) {
-    walk(route, rootId);
+    walk(route, rootId)
   }
-  return routeManifest;
+  return routeManifest
 }
 function createRouteId(file) {
-  return Path.normalize(stripFileExtension(file));
+  return Path.normalize(stripFileExtension(file))
 }
 function stripFileExtension(file) {
-  return file.replace(/\.[a-z0-9]+$/i, "");
+  return file.replace(/\.[a-z0-9]+$/i, '')
 }
-var Path, v, import_pick, routeConfigEntrySchema, resolvedRouteConfigSchema;
+var Path, v, import_pick, routeConfigEntrySchema, resolvedRouteConfigSchema
 var init_routes = __esm({
-  "config/routes.ts"() {
-    "use strict";
-    Path = __toESM(require("pathe"));
-    v = __toESM(require("valibot"));
-    import_pick = __toESM(require("lodash/pick"));
-    init_invariant();
+  'config/routes.ts'() {
+    'use strict'
+    Path = __toESM(require('pathe'))
+    v = __toESM(require('valibot'))
+    import_pick = __toESM(require('lodash/pick'))
+    init_invariant()
     routeConfigEntrySchema = v.pipe(
-      v.custom((value) => {
-        return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
-      }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
+      v.custom(value => {
+        return !(
+          typeof value === 'object' &&
+          value !== null &&
+          'then' in value &&
+          'catch' in value
+        )
+      }, 'Invalid type: Expected object but received a promise. Did you forget to await?'),
       v.object({
         id: v.optional(v.string()),
         path: v.optional(v.string()),
         index: v.optional(v.boolean()),
         caseSensitive: v.optional(v.boolean()),
         file: v.string(),
-        children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
-      })
-    );
-    resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
-  }
-});
+        children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema))),
+      }),
+    )
+    resolvedRouteConfigSchema = v.array(routeConfigEntrySchema)
+  },
+})
 
 // cli/detectPackageManager.ts
 var init_detectPackageManager = __esm({
-  "cli/detectPackageManager.ts"() {
-    "use strict";
-  }
-});
+  'cli/detectPackageManager.ts'() {
+    'use strict'
+  },
+})
 
 // config/config.ts
 function ok(value) {
-  return { ok: true, value };
+  return { ok: true, value }
 }
 function err(error) {
-  return { ok: false, error };
+  return { ok: false, error }
 }
-async function resolveConfig({
-  root,
-  viteNodeContext,
-  reactRouterConfigFile
-}) {
-  let reactRouterUserConfig = {};
+async function resolveConfig({ root, viteNodeContext, reactRouterConfigFile }) {
+  let reactRouterUserConfig = {}
   if (reactRouterConfigFile) {
     try {
       if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
-        return err(`${reactRouterConfigFile} no longer exists`);
+        return err(`${reactRouterConfigFile} no longer exists`)
       }
       let configModule = await viteNodeContext.runner.executeFile(
-        reactRouterConfigFile
-      );
+        reactRouterConfigFile,
+      )
       if (configModule.default === void 0) {
-        return err(`${reactRouterConfigFile} must provide a default export`);
+        return err(`${reactRouterConfigFile} must provide a default export`)
       }
-      if (typeof configModule.default !== "object") {
-        return err(`${reactRouterConfigFile} must export a config`);
+      if (typeof configModule.default !== 'object') {
+        return err(`${reactRouterConfigFile} must export a config`)
       }
-      reactRouterUserConfig = configModule.default;
+      reactRouterUserConfig = configModule.default
     } catch (error) {
-      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
+      return err(`Error loading ${reactRouterConfigFile}: ${error}`)
     }
   }
-  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
-  let presets = (await Promise.all(
-    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
-      if (!preset.name) {
-        throw new Error(
-          "React Router presets must have a `name` property defined."
-        );
-      }
-      if (!preset.reactRouterConfig) {
-        return null;
-      }
-      let configPreset = (0, import_omit.default)(
-        await preset.reactRouterConfig({ reactRouterUserConfig }),
-        excludedConfigPresetKeys
-      );
-      return configPreset;
-    })
-  )).filter(function isNotNull(value) {
-    return value !== null;
-  });
+  reactRouterUserConfig = deepFreeze(
+    (0, import_cloneDeep.default)(reactRouterUserConfig),
+  )
+  let presets = (
+    await Promise.all(
+      (reactRouterUserConfig.presets ?? []).map(async preset => {
+        if (!preset.name) {
+          throw new Error(
+            'React Router presets must have a `name` property defined.',
+          )
+        }
+        if (!preset.reactRouterConfig) {
+          return null
+        }
+        let configPreset = (0, import_omit.default)(
+          await preset.reactRouterConfig({ reactRouterUserConfig }),
+          excludedConfigPresetKeys,
+        )
+        return configPreset
+      }),
+    )
+  ).filter(function isNotNull(value) {
+    return value !== null
+  })
   let defaults = {
-    basename: "/",
-    buildDirectory: "build",
-    serverBuildFile: "index.js",
-    serverModuleFormat: "esm",
-    ssr: true
-  };
+    basename: '/',
+    buildDirectory: 'build',
+    serverBuildFile: 'index.js',
+    serverModuleFormat: 'esm',
+    ssr: true,
+  }
   let {
     appDirectory: userAppDirectory,
     basename: basename2,
@@ -292,76 +309,96 @@ async function resolveConfig({
     serverBuildFile,
     serverBundles,
     serverModuleFormat,
-    ssr
+    ssr,
   } = {
     ...defaults,
     // Default values should be completely overridden by user/preset config, not merged
-    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
-  };
+    ...mergeReactRouterConfig(...presets, reactRouterUserConfig),
+  }
   if (!ssr && serverBundles) {
-    serverBundles = void 0;
+    serverBundles = void 0
   }
-  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
+  let isValidPrerenderConfig =
+    prerender == null ||
+    typeof prerender === 'boolean' ||
+    Array.isArray(prerender) ||
+    typeof prerender === 'function'
   if (!isValidPrerenderConfig) {
     return err(
-      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
-    );
+      'The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths',
+    )
   }
-  let appDirectory = import_pathe.default.resolve(root, userAppDirectory || "app");
-  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory);
-  let rootRouteFile = findEntry(appDirectory, "root");
+  let appDirectory = import_pathe.default.resolve(
+    root,
+    userAppDirectory || 'app',
+  )
+  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory)
+  let rootRouteFile = findEntry(appDirectory, 'root')
   if (!rootRouteFile) {
     let rootRouteDisplayPath = import_pathe.default.relative(
       root,
-      import_pathe.default.join(appDirectory, "root.tsx")
-    );
+      import_pathe.default.join(appDirectory, 'root.tsx'),
+    )
     return err(
-      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
-    );
+      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`,
+    )
   }
   let routes2 = {
-    root: { path: "", id: "root", file: rootRouteFile }
-  };
-  let routeConfigFile = findEntry(appDirectory, "routes");
+    root: { path: '', id: 'root', file: rootRouteFile },
+  }
+  let routeConfigFile = findEntry(appDirectory, 'routes')
   try {
     if (!routeConfigFile) {
       let routeConfigDisplayPath = import_pathe.default.relative(
         root,
-        import_pathe.default.join(appDirectory, "routes.ts")
-      );
-      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
+        import_pathe.default.join(appDirectory, 'routes.ts'),
+      )
+      return err(`Route config file not found at "${routeConfigDisplayPath}".`)
     }
-    setAppDirectory(appDirectory);
-    let routeConfigExport = (await viteNodeContext.runner.executeFile(
-      import_pathe.default.join(appDirectory, routeConfigFile)
-    )).default;
-    let routeConfig = await routeConfigExport;
+    setAppDirectory(appDirectory)
+    let routeConfigExport = (
+      await viteNodeContext.runner.executeFile(
+        import_pathe.default.join(appDirectory, routeConfigFile),
+      )
+    ).default
+    let routeConfig = await routeConfigExport
     let result = validateRouteConfig({
       routeConfigFile,
-      routeConfig
-    });
+      routeConfig,
+    })
     if (!result.valid) {
-      return err(result.message);
+      return err(result.message)
     }
     routes2 = {
       ...routes2,
-      ...configRoutesToRouteManifest(appDirectory, routeConfig)
-    };
+      ...configRoutesToRouteManifest(appDirectory, routeConfig),
+    }
   } catch (error) {
     return err(
       [
-        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
-        "",
-        error.loc?.file && error.loc?.column && error.frame ? [
-          import_pathe.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
-          error.frame.trim?.()
-        ] : error.stack
-      ].flat().join("\n")
-    );
+        import_picocolors.default.red(
+          `Route config in "${routeConfigFile}" is invalid.`,
+        ),
+        '',
+        error.loc?.file && error.loc?.column && error.frame
+          ? [
+              import_pathe.default.relative(appDirectory, error.loc.file) +
+                ':' +
+                error.loc.line +
+                ':' +
+                error.loc.column,
+              error.frame.trim?.(),
+            ]
+          : error.stack,
+      ]
+        .flat()
+        .join('\n'),
+    )
   }
   let future = {
-    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false
-  };
+    unstable_optimizeDeps:
+      reactRouterUserConfig.future?.unstable_optimizeDeps ?? false,
+  }
   let reactRouterConfig = deepFreeze({
     appDirectory,
     basename: basename2,
@@ -373,71 +410,77 @@ async function resolveConfig({
     serverBuildFile,
     serverBundles,
     serverModuleFormat,
-    ssr
-  });
+    ssr,
+  })
   for (let preset of reactRouterUserConfig.presets ?? []) {
-    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
+    await preset.reactRouterConfigResolved?.({ reactRouterConfig })
   }
-  return ok(reactRouterConfig);
+  return ok(reactRouterConfig)
 }
-async function createConfigLoader({
-  rootDirectory: root,
-  watch: watch2
-}) {
-  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
+async function createConfigLoader({ rootDirectory: root, watch: watch2 }) {
+  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd()
   let viteNodeContext = await createContext({
     root,
-    mode: watch2 ? "development" : "production",
+    mode: watch2 ? 'development' : 'production',
     server: !watch2 ? { watch: null } : {},
     ssr: {
-      external: ssrExternals
-    }
-  });
-  let reactRouterConfigFile = findEntry(root, "react-router.config", {
-    absolute: true
-  });
-  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
-  let appDirectory;
-  let initialConfigResult = await getConfig();
+      external: ssrExternals,
+    },
+  })
+  let reactRouterConfigFile = findEntry(root, 'react-router.config', {
+    absolute: true,
+  })
+  let getConfig = () =>
+    resolveConfig({ root, viteNodeContext, reactRouterConfigFile })
+  let appDirectory
+  let initialConfigResult = await getConfig()
   if (!initialConfigResult.ok) {
-    throw new Error(initialConfigResult.error);
+    throw new Error(initialConfigResult.error)
   }
-  appDirectory = initialConfigResult.value.appDirectory;
-  let lastConfig = initialConfigResult.value;
-  let fsWatcher;
-  let changeHandlers = [];
+  appDirectory = initialConfigResult.value.appDirectory
+  let lastConfig = initialConfigResult.value
+  let fsWatcher
+  let changeHandlers = []
   return {
     getConfig,
-    onChange: (handler) => {
+    onChange: handler => {
       if (!watch2) {
-        throw new Error(
-          "onChange is not supported when watch mode is disabled"
-        );
+        throw new Error('onChange is not supported when watch mode is disabled')
       }
-      changeHandlers.push(handler);
+      changeHandlers.push(handler)
       if (!fsWatcher) {
         fsWatcher = import_chokidar.default.watch(
           [
-            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
-            appDirectory
+            ...(reactRouterConfigFile ? [reactRouterConfigFile] : []),
+            appDirectory,
           ],
-          { ignoreInitial: true }
-        );
-        fsWatcher.on("all", async (...args) => {
-          let [event, rawFilepath] = args;
-          let filepath = import_pathe.default.normalize(rawFilepath);
-          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe.default.normalize(appDirectory));
+          { ignoreInitial: true },
+        )
+        fsWatcher.on('all', async (...args) => {
+          let [event, rawFilepath] = args
+          let filepath = import_pathe.default.normalize(rawFilepath)
+          let appFileAddedOrRemoved =
+            appDirectory &&
+            (event === 'add' || event === 'unlink') &&
+            filepath.startsWith(import_pathe.default.normalize(appDirectory))
           let configCodeUpdated = Boolean(
-            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
-          );
+            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath),
+          )
           if (configCodeUpdated || appFileAddedOrRemoved) {
-            viteNodeContext.devServer?.moduleGraph.invalidateAll();
-            viteNodeContext.runner?.moduleCache.clear();
+            viteNodeContext.devServer?.moduleGraph.invalidateAll()
+            viteNodeContext.runner?.moduleCache.clear()
           }
           if (appFileAddedOrRemoved || configCodeUpdated) {
-            let result = await getConfig();
-            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
-            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
+            let result = await getConfig()
+            let configChanged =
+              result.ok &&
+              !(0, import_isEqual.default)(lastConfig, result.value)
+            let routeConfigChanged =
+              result.ok &&
+              !(0, import_isEqual.default)(
+                lastConfig?.routes,
+                result.value.routes,
+              )
             for (let handler2 of changeHandlers) {
               handler2({
                 result,
@@ -445,163 +488,199 @@ async function createConfigLoader({
                 configChanged,
                 routeConfigChanged,
                 path: filepath,
-                event
-              });
+                event,
+              })
             }
             if (result.ok) {
-              lastConfig = result.value;
+              lastConfig = result.value
             }
           }
-        });
+        })
       }
       return () => {
         changeHandlers = changeHandlers.filter(
-          (changeHandler) => changeHandler !== handler
-        );
-      };
+          changeHandler => changeHandler !== handler,
+        )
+      }
     },
     close: async () => {
-      changeHandlers = [];
-      await viteNodeContext.devServer.close();
-      await fsWatcher?.close();
-    }
-  };
+      changeHandlers = []
+      await viteNodeContext.devServer.close()
+      await fsWatcher?.close()
+    },
+  }
 }
 function isInReactRouterMonorepo() {
   let serverRuntimePath = import_pathe.default.dirname(
-    require.resolve("@react-router/node/package.json")
-  );
+    require.resolve('@react-router/node/package.json'),
+  )
   let serverRuntimeParentDir = import_pathe.default.basename(
-    import_pathe.default.resolve(serverRuntimePath, "..")
-  );
-  return serverRuntimeParentDir === "packages";
+    import_pathe.default.resolve(serverRuntimePath, '..'),
+  )
+  return serverRuntimeParentDir === 'packages'
 }
 function findEntry(dir, basename2, options) {
   for (let ext of entryExts) {
-    let file = import_pathe.default.resolve(dir, basename2 + ext);
+    let file = import_pathe.default.resolve(dir, basename2 + ext)
     if (import_node_fs.default.existsSync(file)) {
-      return options?.absolute ?? false ? file : import_pathe.default.relative(dir, file);
+      return options?.absolute ?? false
+        ? file
+        : import_pathe.default.relative(dir, file)
     }
   }
-  return void 0;
+  return void 0
 }
-var import_node_fs, import_node_child_process, import_package_json, import_pathe, import_chokidar, import_picocolors, import_pick2, import_omit, import_cloneDeep, import_isEqual, excludedConfigPresetKeys, branchRouteProperties, configRouteToBranchRoute, mergeReactRouterConfig, deepFreeze, ssrExternals, entryExts;
+var import_node_fs,
+  import_node_child_process,
+  import_package_json,
+  import_pathe,
+  import_chokidar,
+  import_picocolors,
+  import_pick2,
+  import_omit,
+  import_cloneDeep,
+  import_isEqual,
+  excludedConfigPresetKeys,
+  branchRouteProperties,
+  configRouteToBranchRoute,
+  mergeReactRouterConfig,
+  deepFreeze,
+  ssrExternals,
+  entryExts
 var init_config = __esm({
-  "config/config.ts"() {
-    "use strict";
-    import_node_fs = __toESM(require("fs"));
-    import_node_child_process = require("child_process");
-    import_package_json = __toESM(require("@npmcli/package-json"));
-    init_vite_node();
-    import_pathe = __toESM(require("pathe"));
-    import_chokidar = __toESM(require("chokidar"));
-    import_picocolors = __toESM(require("picocolors"));
-    import_pick2 = __toESM(require("lodash/pick"));
-    import_omit = __toESM(require("lodash/omit"));
-    import_cloneDeep = __toESM(require("lodash/cloneDeep"));
-    import_isEqual = __toESM(require("lodash/isEqual"));
-    init_routes();
-    init_detectPackageManager();
-    excludedConfigPresetKeys = ["presets"];
-    branchRouteProperties = [
-      "id",
-      "path",
-      "file",
-      "index"
-    ];
-    configRouteToBranchRoute = (configRoute) => (0, import_pick2.default)(configRoute, branchRouteProperties);
+  'config/config.ts'() {
+    'use strict'
+    import_node_fs = __toESM(require('fs'))
+    import_node_child_process = require('child_process')
+    import_package_json = __toESM(require('@npmcli/package-json'))
+    init_vite_node()
+    import_pathe = __toESM(require('pathe'))
+    import_chokidar = __toESM(require('chokidar'))
+    import_picocolors = __toESM(require('picocolors'))
+    import_pick2 = __toESM(require('lodash/pick'))
+    import_omit = __toESM(require('lodash/omit'))
+    import_cloneDeep = __toESM(require('lodash/cloneDeep'))
+    import_isEqual = __toESM(require('lodash/isEqual'))
+    init_routes()
+    init_detectPackageManager()
+    excludedConfigPresetKeys = ['presets']
+    branchRouteProperties = ['id', 'path', 'file', 'index']
+    configRouteToBranchRoute = configRoute =>
+      (0, import_pick2.default)(configRoute, branchRouteProperties)
     mergeReactRouterConfig = (...configs) => {
       let reducer = (configA, configB) => {
-        let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
+        let mergeRequired = key =>
+          configA[key] !== void 0 && configB[key] !== void 0
         return {
           ...configA,
           ...configB,
-          ...mergeRequired("buildEnd") ? {
-            buildEnd: async (...args) => {
-              await Promise.all([
-                configA.buildEnd?.(...args),
-                configB.buildEnd?.(...args)
-              ]);
-            }
-          } : {},
-          ...mergeRequired("future") ? {
-            future: {
-              ...configA.future,
-              ...configB.future
-            }
-          } : {},
-          ...mergeRequired("presets") ? {
-            presets: [...configA.presets ?? [], ...configB.presets ?? []]
-          } : {}
-        };
-      };
-      return configs.reduce(reducer, {});
-    };
-    deepFreeze = (o) => {
-      Object.freeze(o);
-      let oIsFunction = typeof o === "function";
-      let hasOwnProp = Object.prototype.hasOwnProperty;
-      Object.getOwnPropertyNames(o).forEach(function(prop) {
-        if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
-          deepFreeze(o[prop]);
+          ...(mergeRequired('buildEnd')
+            ? {
+                buildEnd: async (...args) => {
+                  await Promise.all([
+                    configA.buildEnd?.(...args),
+                    configB.buildEnd?.(...args),
+                  ])
+                },
+              }
+            : {}),
+          ...(mergeRequired('future')
+            ? {
+                future: {
+                  ...configA.future,
+                  ...configB.future,
+                },
+              }
+            : {}),
+          ...(mergeRequired('presets')
+            ? {
+                presets: [
+                  ...(configA.presets ?? []),
+                  ...(configB.presets ?? []),
+                ],
+              }
+            : {}),
         }
-      });
-      return o;
-    };
-    ssrExternals = isInReactRouterMonorepo() ? [
-      // This is only needed within this repo because these packages
-      // are linked to a directory outside of node_modules so Vite
-      // treats them as internal code by default.
-      "react-router",
-      "react-router-dom",
-      "@react-router/architect",
-      "@react-router/cloudflare",
-      "@react-router/dev",
-      "@react-router/express",
-      "@react-router/node",
-      "@react-router/serve"
-    ] : void 0;
-    entryExts = [".js", ".jsx", ".ts", ".tsx"];
-  }
-});
+      }
+      return configs.reduce(reducer, {})
+    }
+    deepFreeze = o => {
+      Object.freeze(o)
+      let oIsFunction = typeof o === 'function'
+      let hasOwnProp = Object.prototype.hasOwnProperty
+      Object.getOwnPropertyNames(o).forEach(function (prop) {
+        if (
+          hasOwnProp.call(o, prop) &&
+          (oIsFunction
+            ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'
+            : true) &&
+          o[prop] !== null &&
+          (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
+          !Object.isFrozen(o[prop])
+        ) {
+          deepFreeze(o[prop])
+        }
+      })
+      return o
+    }
+    ssrExternals = isInReactRouterMonorepo()
+      ? [
+          // This is only needed within this repo because these packages
+          // are linked to a directory outside of node_modules so Vite
+          // treats them as internal code by default.
+          'react-router',
+          'react-router-dom',
+          '@react-router/architect',
+          '@react-router/cloudflare',
+          '@react-router/dev',
+          '@react-router/express',
+          '@react-router/node',
+          '@react-router/serve',
+        ]
+      : void 0
+    entryExts = ['.js', '.jsx', '.ts', '.tsx']
+  },
+})
 
 // typegen/paths.ts
 function getTypesDir(ctx) {
-  return Path2.join(ctx.rootDirectory, ".react-router/types");
+  return Path2.join(ctx.rootDirectory, '.react-router/types')
 }
 function getTypesPath(ctx, route) {
   return Path2.join(
     getTypesDir(ctx),
     Path2.relative(ctx.rootDirectory, ctx.config.appDirectory),
     Path2.dirname(route.file),
-    "+types/" + Pathe.filename(route.file) + ".ts"
-  );
+    '+types/' + Pathe.filename(route.file) + '.ts',
+  )
 }
-var Path2, Pathe;
+var Path2, Pathe
 var init_paths = __esm({
-  "typegen/paths.ts"() {
-    "use strict";
-    Path2 = __toESM(require("pathe"));
-    Pathe = __toESM(require("pathe/utils"));
-  }
-});
+  'typegen/paths.ts'() {
+    'use strict'
+    Path2 = __toESM(require('pathe'))
+    Pathe = __toESM(require('pathe/utils'))
+  },
+})
 
 // typegen/generate.ts
 function generate(ctx, route) {
-  const lineage = getRouteLineage(ctx.config.routes, route);
-  const urlpath = lineage.map((route2) => route2.path).join("/");
-  const typesPath = getTypesPath(ctx, route);
-  const parents = lineage.slice(0, -1);
-  const parentTypeImports = parents.map((parent, i) => {
-    const rel = Path3.relative(
-      Path3.dirname(typesPath),
-      getTypesPath(ctx, parent)
-    );
-    const indent = i === 0 ? "" : "  ".repeat(2);
-    let source = noExtension(rel);
-    if (!source.startsWith("../")) source = "./" + source;
-    return `${indent}import type { Info as Parent${i} } from "${source}"`;
-  }).join("\n");
+  const lineage = getRouteLineage(ctx.config.routes, route)
+  const urlpath = lineage.map(route2 => route2.path).join('/')
+  const typesPath = getTypesPath(ctx, route)
+  const parents = lineage.slice(0, -1)
+  const parentTypeImports = parents
+    .map((parent, i) => {
+      const rel = Path3.relative(
+        Path3.dirname(typesPath),
+        getTypesPath(ctx, parent),
+      )
+      const indent = i === 0 ? '' : '  '.repeat(2)
+      let source = noExtension(rel)
+      if (!source.startsWith('../')) source = './' + source
+      return `${indent}import type { Info as Parent${i} } from "${source}.ts"`
+    })
+    .join('\n')
   return import_dedent.default`
     // React Router generated types for route:
     // ${route.file}
@@ -610,10 +689,10 @@ function generate(ctx, route) {
 
     ${parentTypeImports}
 
-    type Module = typeof import("../${Pathe2.filename(route.file)}")
+    type Module = typeof import("../${Pathe2.filename(route.file)}.ts")
 
     export type Info = {
-      parents: [${parents.map((_, i) => `Parent${i}`).join(", ")}],
+      parents: [${parents.map((_, i) => `Parent${i}`).join(', ')}],
       id: "${route.id}"
       file: "${route.file}"
       path: "${route.path}"
@@ -643,316 +722,349 @@ function generate(ctx, route) {
       export type ComponentProps = T.CreateComponentProps<Info>
       export type ErrorBoundaryProps = T.CreateErrorBoundaryProps<Info>
     }
-  `;
+  `
 }
 function getRouteLineage(routes2, route) {
-  const result = [];
+  const result = []
   while (route) {
-    result.push(route);
-    if (!route.parentId) break;
-    route = routes2[route.parentId];
+    result.push(route)
+    if (!route.parentId) break
+    route = routes2[route.parentId]
   }
-  result.reverse();
-  return result;
+  result.reverse()
+  return result
 }
 function formatParamProperties(urlpath) {
-  const params = parseParams(urlpath);
+  const params = parseParams(urlpath)
   const properties = Object.entries(params).map(([name, values]) => {
     if (values.length === 1) {
-      const isOptional = values[0];
-      return isOptional ? `"${name}"?: string` : `"${name}": string`;
+      const isOptional = values[0]
+      return isOptional ? `"${name}"?: string` : `"${name}": string`
     }
-    const items = values.map(
-      (isOptional) => isOptional ? "string | undefined" : "string"
-    );
-    return `"${name}": [${items.join(", ")}]`;
-  });
-  return properties.join("; ");
+    const items = values.map(isOptional =>
+      isOptional ? 'string | undefined' : 'string',
+    )
+    return `"${name}": [${items.join(', ')}]`
+  })
+  return properties.join('; ')
 }
 function parseParams(urlpath) {
-  const result = {};
-  let segments = urlpath.split("/");
-  segments.forEach((segment) => {
-    const match = segment.match(/^:([\w-]+)(\?)?/);
-    if (!match) return;
-    const param = match[1];
-    const isOptional = match[2] !== void 0;
-    result[param] ??= [];
-    result[param].push(isOptional);
-    return;
-  });
-  const hasSplat = segments.at(-1) === "*";
-  if (hasSplat) result["*"] = [false];
-  return result;
+  const result = {}
+  let segments = urlpath.split('/')
+  segments.forEach(segment => {
+    const match = segment.match(/^:([\w-]+)(\?)?/)
+    if (!match) return
+    const param = match[1]
+    const isOptional = match[2] !== void 0
+    result[param] ??= []
+    result[param].push(isOptional)
+    return
+  })
+  const hasSplat = segments.at(-1) === '*'
+  if (hasSplat) result['*'] = [false]
+  return result
 }
-var import_dedent, Path3, Pathe2, noExtension;
+var import_dedent, Path3, Pathe2, noExtension
 var init_generate = __esm({
-  "typegen/generate.ts"() {
-    "use strict";
-    import_dedent = __toESM(require("dedent"));
-    Path3 = __toESM(require("pathe"));
-    Pathe2 = __toESM(require("pathe/utils"));
-    init_paths();
-    noExtension = (path8) => Path3.join(Path3.dirname(path8), Pathe2.filename(path8));
-  }
-});
+  'typegen/generate.ts'() {
+    'use strict'
+    import_dedent = __toESM(require('dedent'))
+    Path3 = __toESM(require('pathe'))
+    Pathe2 = __toESM(require('pathe/utils'))
+    init_paths()
+    noExtension = path8 =>
+      Path3.join(Path3.dirname(path8), Pathe2.filename(path8))
+  },
+})
 
 // typegen/index.ts
 async function run(rootDirectory) {
-  const ctx = await createContext2({ rootDirectory, watch: false });
-  await writeAll(ctx);
+  const ctx = await createContext2({ rootDirectory, watch: false })
+  await writeAll(ctx)
 }
 async function watch(rootDirectory, { logger } = {}) {
-  const ctx = await createContext2({ rootDirectory, watch: true });
-  await writeAll(ctx);
-  logger?.info(import_picocolors2.default.green("generated types"), { timestamp: true, clear: true });
+  const ctx = await createContext2({ rootDirectory, watch: true })
+  await writeAll(ctx)
+  logger?.info(import_picocolors2.default.green('generated types'), {
+    timestamp: true,
+    clear: true,
+  })
   ctx.configLoader.onChange(async ({ result, routeConfigChanged }) => {
     if (!result.ok) {
-      logger?.error(import_picocolors2.default.red(result.error), { timestamp: true, clear: true });
-      return;
+      logger?.error(import_picocolors2.default.red(result.error), {
+        timestamp: true,
+        clear: true,
+      })
+      return
     }
-    ctx.config = result.value;
+    ctx.config = result.value
     if (routeConfigChanged) {
-      await writeAll(ctx);
-      logger?.info(import_picocolors2.default.green("regenerated types"), {
+      await writeAll(ctx)
+      logger?.info(import_picocolors2.default.green('regenerated types'), {
         timestamp: true,
-        clear: true
-      });
+        clear: true,
+      })
     }
-  });
+  })
   return {
-    close: async () => await ctx.configLoader.close()
-  };
+    close: async () => await ctx.configLoader.close(),
+  }
 }
-async function createContext2({
-  rootDirectory,
-  watch: watch2
-}) {
-  const configLoader = await createConfigLoader({ rootDirectory, watch: watch2 });
-  const configResult = await configLoader.getConfig();
+async function createContext2({ rootDirectory, watch: watch2 }) {
+  const configLoader = await createConfigLoader({
+    rootDirectory,
+    watch: watch2,
+  })
+  const configResult = await configLoader.getConfig()
   if (!configResult.ok) {
-    throw new Error(configResult.error);
+    throw new Error(configResult.error)
   }
-  const config = configResult.value;
+  const config = configResult.value
   return {
     configLoader,
     rootDirectory,
-    config
-  };
+    config,
+  }
 }
 async function writeAll(ctx) {
-  const typegenDir = getTypesDir(ctx);
-  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true });
-  Object.values(ctx.config.routes).forEach((route) => {
-    const typesPath = getTypesPath(ctx, route);
-    const content = generate(ctx, route);
-    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), { recursive: true });
-    import_node_fs2.default.writeFileSync(typesPath, content);
-  });
+  const typegenDir = getTypesDir(ctx)
+  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true })
+  Object.values(ctx.config.routes).forEach(route => {
+    const typesPath = getTypesPath(ctx, route)
+    const content = generate(ctx, route)
+    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), {
+      recursive: true,
+    })
+    import_node_fs2.default.writeFileSync(typesPath, content)
+  })
 }
-var import_node_fs2, Path4, import_picocolors2;
+var import_node_fs2, Path4, import_picocolors2
 var init_typegen = __esm({
-  "typegen/index.ts"() {
-    "use strict";
-    import_node_fs2 = __toESM(require("fs"));
-    Path4 = __toESM(require("pathe"));
-    import_picocolors2 = __toESM(require("picocolors"));
-    init_config();
-    init_generate();
-    init_paths();
-  }
-});
+  'typegen/index.ts'() {
+    'use strict'
+    import_node_fs2 = __toESM(require('fs'))
+    Path4 = __toESM(require('pathe'))
+    import_picocolors2 = __toESM(require('picocolors'))
+    init_config()
+    init_generate()
+    init_paths()
+  },
+})
 
 // vite/babel.ts
-var import_parser, t, traverse, generate2;
+var import_parser, t, traverse, generate2
 var init_babel = __esm({
-  "vite/babel.ts"() {
-    "use strict";
-    import_parser = require("@babel/parser");
-    t = __toESM(require("@babel/types"));
-    traverse = require("@babel/traverse").default;
-    generate2 = require("@babel/generator").default;
-  }
-});
+  'vite/babel.ts'() {
+    'use strict'
+    import_parser = require('@babel/parser')
+    t = __toESM(require('@babel/types'))
+    traverse = require('@babel/traverse').default
+    generate2 = require('@babel/generator').default
+  },
+})
 
 // vite/node-adapter.ts
-var import_node_events, import_node_stream, import_set_cookie_parser, import_node;
+var import_node_events,
+  import_node_stream,
+  import_set_cookie_parser,
+  import_node
 var init_node_adapter = __esm({
-  "vite/node-adapter.ts"() {
-    "use strict";
-    import_node_events = require("events");
-    import_node_stream = require("stream");
-    import_set_cookie_parser = require("set-cookie-parser");
-    import_node = require("@react-router/node");
-    init_invariant();
-  }
-});
+  'vite/node-adapter.ts'() {
+    'use strict'
+    import_node_events = require('events')
+    import_node_stream = require('stream')
+    import_set_cookie_parser = require('set-cookie-parser')
+    import_node = require('@react-router/node')
+    init_invariant()
+  },
+})
 
 // vite/resolve-file-url.ts
-var path2;
+var path2
 var init_resolve_file_url = __esm({
-  "vite/resolve-file-url.ts"() {
-    "use strict";
-    path2 = __toESM(require("path"));
-    init_import_vite_esm_sync();
-  }
-});
+  'vite/resolve-file-url.ts'() {
+    'use strict'
+    path2 = __toESM(require('path'))
+    init_import_vite_esm_sync()
+  },
+})
 
 // vite/styles.ts
-var path3, import_react_router, cssFileRegExp, cssModulesRegExp;
+var path3, import_react_router, cssFileRegExp, cssModulesRegExp
 var init_styles = __esm({
-  "vite/styles.ts"() {
-    "use strict";
-    path3 = __toESM(require("path"));
-    import_react_router = require("react-router");
-    init_resolve_file_url();
-    cssFileRegExp = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
-    cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`);
-  }
-});
+  'vite/styles.ts'() {
+    'use strict'
+    path3 = __toESM(require('path'))
+    import_react_router = require('react-router')
+    init_resolve_file_url()
+    cssFileRegExp =
+      /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/
+    cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`)
+  },
+})
 
 // vite/vmod.ts
-var id;
+var id
 var init_vmod = __esm({
-  "vite/vmod.ts"() {
-    "use strict";
-    id = (name) => `virtual:react-router/${name}`;
-  }
-});
+  'vite/vmod.ts'() {
+    'use strict'
+    id = name => `virtual:react-router/${name}`
+  },
+})
 
 // vite/combine-urls.ts
 var init_combine_urls = __esm({
-  "vite/combine-urls.ts"() {
-    "use strict";
-  }
-});
+  'vite/combine-urls.ts'() {
+    'use strict'
+  },
+})
 
 // vite/remove-exports.ts
-var import_babel_dead_code_elimination;
+var import_babel_dead_code_elimination
 var init_remove_exports = __esm({
-  "vite/remove-exports.ts"() {
-    "use strict";
-    import_babel_dead_code_elimination = require("babel-dead-code-elimination");
-    init_babel();
-  }
-});
+  'vite/remove-exports.ts'() {
+    'use strict'
+    import_babel_dead_code_elimination = require('babel-dead-code-elimination')
+    init_babel()
+  },
+})
 
 // vite/with-props.ts
-var import_dedent2, vmodId;
+var import_dedent2, vmodId
 var init_with_props = __esm({
-  "vite/with-props.ts"() {
-    "use strict";
-    import_dedent2 = __toESM(require("dedent"));
-    init_babel();
-    init_vmod();
-    vmodId = id("with-props");
-  }
-});
+  'vite/with-props.ts'() {
+    'use strict'
+    import_dedent2 = __toESM(require('dedent'))
+    init_babel()
+    init_vmod()
+    vmodId = id('with-props')
+  },
+})
 
 // vite/plugin.ts
-async function resolveViteConfig({
-  configFile,
-  mode,
-  root
-}) {
-  let vite2 = await import("vite");
+async function resolveViteConfig({ configFile, mode, root }) {
+  let vite2 = await import('vite')
   let viteConfig = await vite2.resolveConfig(
     { mode, configFile, root },
-    "build",
+    'build',
     // command
-    "production",
+    'production',
     // default mode
-    "production"
+    'production',
     // default NODE_ENV
-  );
-  if (typeof viteConfig.build.manifest === "string") {
-    throw new Error("Custom Vite manifest paths are not supported");
+  )
+  if (typeof viteConfig.build.manifest === 'string') {
+    throw new Error('Custom Vite manifest paths are not supported')
   }
-  return viteConfig;
+  return viteConfig
 }
 async function extractPluginContext(viteConfig) {
-  return viteConfig["__reactRouterPluginContext"];
+  return viteConfig['__reactRouterPluginContext']
 }
-async function loadPluginContext({
-  configFile,
-  root
-}) {
+async function loadPluginContext({ configFile, root }) {
   if (!root) {
-    root = process.env.REACT_ROUTER_ROOT || process.cwd();
-  }
-  configFile = configFile ?? findConfig(root, "vite.config", [
-    ".ts",
-    ".cts",
-    ".mts",
-    ".js",
-    ".cjs",
-    ".mjs"
-  ]);
+    root = process.env.REACT_ROUTER_ROOT || process.cwd()
+  }
+  configFile =
+    configFile ??
+    findConfig(root, 'vite.config', [
+      '.ts',
+      '.cts',
+      '.mts',
+      '.js',
+      '.cjs',
+      '.mjs',
+    ])
   if (!configFile) {
-    console.error(import_picocolors3.default.red("Vite config file not found"));
-    process.exit(1);
+    console.error(import_picocolors3.default.red('Vite config file not found'))
+    process.exit(1)
   }
-  let viteConfig = await resolveViteConfig({ configFile, root });
-  let ctx = await extractPluginContext(viteConfig);
+  let viteConfig = await resolveViteConfig({ configFile, root })
+  let ctx = await extractPluginContext(viteConfig)
   if (!ctx) {
     console.error(
-      import_picocolors3.default.red("React Router Vite plugin not found in Vite config")
-    );
-    process.exit(1);
+      import_picocolors3.default.red(
+        'React Router Vite plugin not found in Vite config',
+      ),
+    )
+    process.exit(1)
   }
-  return ctx;
+  return ctx
 }
 function findConfig(dir, basename2, extensions) {
   for (let ext of extensions) {
-    let name = basename2 + ext;
-    let file = path4.join(dir, name);
-    if (fse.existsSync(file)) return file;
+    let name = basename2 + ext
+    let file = path4.join(dir, name)
+    if (fse.existsSync(file)) return file
   }
-  return void 0;
+  return void 0
 }
-var import_node_crypto, path4, url, fse, babel, import_react_router2, import_es_module_lexer, import_jsesc, import_picocolors3, serverBuildId, serverManifestId, browserManifestId, hmrRuntimeId, injectHmrRuntimeId, getServerBuildDirectory, defaultEntriesDir, defaultEntries, REACT_REFRESH_HEADER, REACT_REFRESH_FOOTER;
+var import_node_crypto,
+  path4,
+  url,
+  fse,
+  babel,
+  import_react_router2,
+  import_es_module_lexer,
+  import_jsesc,
+  import_picocolors3,
+  serverBuildId,
+  serverManifestId,
+  browserManifestId,
+  hmrRuntimeId,
+  injectHmrRuntimeId,
+  getServerBuildDirectory,
+  defaultEntriesDir,
+  defaultEntries,
+  REACT_REFRESH_HEADER,
+  REACT_REFRESH_FOOTER
 var init_plugin = __esm({
-  "vite/plugin.ts"() {
-    "use strict";
-    import_node_crypto = require("crypto");
-    path4 = __toESM(require("path"));
-    url = __toESM(require("url"));
-    fse = __toESM(require("fs-extra"));
-    babel = __toESM(require("@babel/core"));
-    import_react_router2 = require("react-router");
-    import_es_module_lexer = require("es-module-lexer");
-    import_jsesc = __toESM(require("jsesc"));
-    import_picocolors3 = __toESM(require("picocolors"));
-    init_typegen();
-    init_invariant();
-    init_babel();
-    init_node_adapter();
-    init_styles();
-    init_vmod();
-    init_resolve_file_url();
-    init_combine_urls();
-    init_remove_exports();
-    init_import_vite_esm_sync();
-    init_config();
-    init_with_props();
-    serverBuildId = id("server-build");
-    serverManifestId = id("server-manifest");
-    browserManifestId = id("browser-manifest");
-    hmrRuntimeId = id("hmr-runtime");
-    injectHmrRuntimeId = id("inject-hmr-runtime");
-    getServerBuildDirectory = (ctx) => path4.join(
-      ctx.reactRouterConfig.buildDirectory,
-      "server",
-      ...ctx.serverBundleBuildConfig ? [ctx.serverBundleBuildConfig.serverBundleId] : []
-    );
+  'vite/plugin.ts'() {
+    'use strict'
+    import_node_crypto = require('crypto')
+    path4 = __toESM(require('path'))
+    url = __toESM(require('url'))
+    fse = __toESM(require('fs-extra'))
+    babel = __toESM(require('@babel/core'))
+    import_react_router2 = require('react-router')
+    import_es_module_lexer = require('es-module-lexer')
+    import_jsesc = __toESM(require('jsesc'))
+    import_picocolors3 = __toESM(require('picocolors'))
+    init_typegen()
+    init_invariant()
+    init_babel()
+    init_node_adapter()
+    init_styles()
+    init_vmod()
+    init_resolve_file_url()
+    init_combine_urls()
+    init_remove_exports()
+    init_import_vite_esm_sync()
+    init_config()
+    init_with_props()
+    serverBuildId = id('server-build')
+    serverManifestId = id('server-manifest')
+    browserManifestId = id('browser-manifest')
+    hmrRuntimeId = id('hmr-runtime')
+    injectHmrRuntimeId = id('inject-hmr-runtime')
+    getServerBuildDirectory = ctx =>
+      path4.join(
+        ctx.reactRouterConfig.buildDirectory,
+        'server',
+        ...(ctx.serverBundleBuildConfig
+          ? [ctx.serverBundleBuildConfig.serverBundleId]
+          : []),
+      )
     defaultEntriesDir = path4.resolve(
-      path4.dirname(require.resolve("@react-router/dev/package.json")),
-      "dist",
-      "config",
-      "defaults"
-    );
-    defaultEntries = fse.readdirSync(defaultEntriesDir).map((filename3) => path4.join(defaultEntriesDir, filename3));
-    invariant(defaultEntries.length > 0, "No default entries found");
+      path4.dirname(require.resolve('@react-router/dev/package.json')),
+      'dist',
+      'config',
+      'defaults',
+    )
+    defaultEntries = fse
+      .readdirSync(defaultEntriesDir)
+      .map(filename3 => path4.join(defaultEntriesDir, filename3))
+    invariant(defaultEntries.length > 0, 'No default entries found')
     REACT_REFRESH_HEADER = `
 import RefreshRuntime from "${hmrRuntimeId}";
 
@@ -973,7 +1085,7 @@ if (import.meta.hot && !inWebWorker) {
     RefreshRuntime.register(type, __SOURCE__ + " " + id)
   };
   window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
-}`.trim();
+}`.trim()
     REACT_REFRESH_FOOTER = `
 if (import.meta.hot && !inWebWorker) {
   window.$RefreshReg$ = prevRefreshReg;
@@ -987,218 +1099,259 @@ if (import.meta.hot && !inWebWorker) {
       if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
     });
   });
-}`.trim();
-  }
-});
+}`.trim()
+  },
+})
 
 // vite/profiler.ts
-var import_node_fs3, import_node_path, import_picocolors4, getSession, start, profileCount, stop;
+var import_node_fs3,
+  import_node_path,
+  import_picocolors4,
+  getSession,
+  start,
+  profileCount,
+  stop
 var init_profiler = __esm({
-  "vite/profiler.ts"() {
-    "use strict";
-    import_node_fs3 = __toESM(require("fs"));
-    import_node_path = __toESM(require("path"));
-    import_picocolors4 = __toESM(require("picocolors"));
-    getSession = () => global.__reactRouter_profile_session;
-    start = async (callback) => {
-      let inspector = await import("inspector").then((r) => r.default);
-      let session = global.__reactRouter_profile_session = new inspector.Session();
-      session.connect();
-      session.post("Profiler.enable", () => {
-        session.post("Profiler.start", callback);
-      });
-    };
-    profileCount = 0;
-    stop = (log) => {
-      let session = getSession();
-      if (!session) return;
+  'vite/profiler.ts'() {
+    'use strict'
+    import_node_fs3 = __toESM(require('fs'))
+    import_node_path = __toESM(require('path'))
+    import_picocolors4 = __toESM(require('picocolors'))
+    getSession = () => global.__reactRouter_profile_session
+    start = async callback => {
+      let inspector = await import('inspector').then(r => r.default)
+      let session = (global.__reactRouter_profile_session =
+        new inspector.Session())
+      session.connect()
+      session.post('Profiler.enable', () => {
+        session.post('Profiler.start', callback)
+      })
+    }
+    profileCount = 0
+    stop = log => {
+      let session = getSession()
+      if (!session) return
       return new Promise((res, rej) => {
-        session.post("Profiler.stop", (err2, { profile }) => {
-          if (err2) return rej(err2);
-          let outPath = import_node_path.default.resolve(`./react-router-${profileCount++}.cpuprofile`);
-          import_node_fs3.default.writeFileSync(outPath, JSON.stringify(profile));
+        session.post('Profiler.stop', (err2, { profile }) => {
+          if (err2) return rej(err2)
+          let outPath = import_node_path.default.resolve(
+            `./react-router-${profileCount++}.cpuprofile`,
+          )
+          import_node_fs3.default.writeFileSync(
+            outPath,
+            JSON.stringify(profile),
+          )
           log(
             import_picocolors4.default.yellow(
-              `CPU profile written to ${import_picocolors4.default.white(import_picocolors4.default.dim(outPath))}`
-            )
-          );
-          global.__reactRouter_profile_session = void 0;
-          res();
-        });
-      });
-    };
-  }
-});
+              `CPU profile written to ${import_picocolors4.default.white(import_picocolors4.default.dim(outPath))}`,
+            ),
+          )
+          global.__reactRouter_profile_session = void 0
+          res()
+        })
+      })
+    }
+  },
+})
 
 // vite/build.ts
-var build_exports = {};
+var build_exports = {}
 __export(build_exports, {
-  build: () => build
-});
+  build: () => build,
+})
 function getAddressableRoutes(routes2) {
-  let nonAddressableIds = /* @__PURE__ */ new Set();
+  let nonAddressableIds = /* @__PURE__ */ new Set()
   for (let id2 in routes2) {
-    let route = routes2[id2];
+    let route = routes2[id2]
     if (route.index) {
       invariant(
         route.parentId,
-        `Expected index route "${route.id}" to have "parentId" set`
-      );
-      nonAddressableIds.add(route.parentId);
+        `Expected index route "${route.id}" to have "parentId" set`,
+      )
+      nonAddressableIds.add(route.parentId)
     }
-    if (typeof route.path !== "string" && !route.index) {
-      nonAddressableIds.add(id2);
+    if (typeof route.path !== 'string' && !route.index) {
+      nonAddressableIds.add(id2)
     }
   }
   return Object.values(routes2).filter(
-    (route) => !nonAddressableIds.has(route.id)
-  );
+    route => !nonAddressableIds.has(route.id),
+  )
 }
 function getRouteBranch(routes2, routeId) {
-  let branch = [];
-  let currentRouteId = routeId;
+  let branch = []
+  let currentRouteId = routeId
   while (currentRouteId) {
-    let route = routes2[currentRouteId];
-    invariant(route, `Missing route for ${currentRouteId}`);
-    branch.push(route);
-    currentRouteId = route.parentId;
+    let route = routes2[currentRouteId]
+    invariant(route, `Missing route for ${currentRouteId}`)
+    branch.push(route)
+    currentRouteId = route.parentId
   }
-  return branch.reverse();
+  return branch.reverse()
 }
 async function getServerBuilds(ctx) {
-  let { rootDirectory } = ctx;
-  const { routes: routes2, serverBuildFile, serverBundles, appDirectory } = ctx.reactRouterConfig;
-  let serverBuildDirectory = getServerBuildDirectory(ctx);
+  let { rootDirectory } = ctx
+  const {
+    routes: routes2,
+    serverBuildFile,
+    serverBundles,
+    appDirectory,
+  } = ctx.reactRouterConfig
+  let serverBuildDirectory = getServerBuildDirectory(ctx)
   if (!serverBundles) {
     return {
       serverBuilds: [{ ssr: true }],
-      buildManifest: { routes: routes2 }
-    };
+      buildManifest: { routes: routes2 },
+    }
   }
-  let { normalizePath } = await import("vite");
-  let resolvedAppDirectory = import_node_path2.default.resolve(rootDirectory, appDirectory);
+  let { normalizePath } = await import('vite')
+  let resolvedAppDirectory = import_node_path2.default.resolve(
+    rootDirectory,
+    appDirectory,
+  )
   let rootRelativeRoutes = Object.fromEntries(
     Object.entries(routes2).map(([id2, route]) => {
-      let filePath = import_node_path2.default.join(resolvedAppDirectory, route.file);
+      let filePath = import_node_path2.default.join(
+        resolvedAppDirectory,
+        route.file,
+      )
       let rootRelativeFilePath = normalizePath(
-        import_node_path2.default.relative(rootDirectory, filePath)
-      );
-      return [id2, { ...route, file: rootRelativeFilePath }];
-    })
-  );
+        import_node_path2.default.relative(rootDirectory, filePath),
+      )
+      return [id2, { ...route, file: rootRelativeFilePath }]
+    }),
+  )
   let buildManifest = {
     serverBundles: {},
     routeIdToServerBundleId: {},
-    routes: rootRelativeRoutes
-  };
-  let serverBundleBuildConfigById = /* @__PURE__ */ new Map();
+    routes: rootRelativeRoutes,
+  }
+  let serverBundleBuildConfigById = /* @__PURE__ */ new Map()
   await Promise.all(
-    getAddressableRoutes(routes2).map(async (route) => {
-      let branch = getRouteBranch(routes2, route.id);
+    getAddressableRoutes(routes2).map(async route => {
+      let branch = getRouteBranch(routes2, route.id)
       let serverBundleId = await serverBundles({
-        branch: branch.map(
-          (route2) => configRouteToBranchRoute({
+        branch: branch.map(route2 =>
+          configRouteToBranchRoute({
             ...route2,
             // Ensure absolute paths are passed to the serverBundles function
-            file: import_node_path2.default.join(resolvedAppDirectory, route2.file)
-          })
-        )
-      });
-      if (typeof serverBundleId !== "string") {
-        throw new Error(`The "serverBundles" function must return a string`);
+            file: import_node_path2.default.join(
+              resolvedAppDirectory,
+              route2.file,
+            ),
+          }),
+        ),
+      })
+      if (typeof serverBundleId !== 'string') {
+        throw new Error(`The "serverBundles" function must return a string`)
       }
       if (!/^[a-zA-Z0-9-_]+$/.test(serverBundleId)) {
         throw new Error(
-          `The "serverBundles" function must only return strings containing alphanumeric characters, hyphens and underscores.`
-        );
+          `The "serverBundles" function must only return strings containing alphanumeric characters, hyphens and underscores.`,
+        )
       }
-      buildManifest.routeIdToServerBundleId[route.id] = serverBundleId;
+      buildManifest.routeIdToServerBundleId[route.id] = serverBundleId
       let relativeServerBundleDirectory = import_node_path2.default.relative(
         rootDirectory,
-        import_node_path2.default.join(serverBuildDirectory, serverBundleId)
-      );
-      let serverBuildConfig = serverBundleBuildConfigById.get(serverBundleId);
+        import_node_path2.default.join(serverBuildDirectory, serverBundleId),
+      )
+      let serverBuildConfig = serverBundleBuildConfigById.get(serverBundleId)
       if (!serverBuildConfig) {
         buildManifest.serverBundles[serverBundleId] = {
           id: serverBundleId,
           file: normalizePath(
-            import_node_path2.default.join(relativeServerBundleDirectory, serverBuildFile)
-          )
-        };
+            import_node_path2.default.join(
+              relativeServerBundleDirectory,
+              serverBuildFile,
+            ),
+          ),
+        }
         serverBuildConfig = {
           routes: {},
-          serverBundleId
-        };
-        serverBundleBuildConfigById.set(serverBundleId, serverBuildConfig);
+          serverBundleId,
+        }
+        serverBundleBuildConfigById.set(serverBundleId, serverBuildConfig)
       }
       for (let route2 of branch) {
-        serverBuildConfig.routes[route2.id] = route2;
+        serverBuildConfig.routes[route2.id] = route2
       }
-    })
-  );
+    }),
+  )
   let serverBuilds = Array.from(serverBundleBuildConfigById.values()).map(
-    (serverBundleBuildConfig) => {
+    serverBundleBuildConfig => {
       let serverBuild = {
         ssr: true,
-        serverBundleBuildConfig
-      };
-      return serverBuild;
-    }
-  );
+        serverBundleBuildConfig,
+      }
+      return serverBuild
+    },
+  )
   return {
     serverBuilds,
-    buildManifest
-  };
+    buildManifest,
+  }
 }
 async function cleanBuildDirectory(viteConfig, ctx) {
-  let buildDirectory = ctx.reactRouterConfig.buildDirectory;
+  let buildDirectory = ctx.reactRouterConfig.buildDirectory
   let isWithinRoot = () => {
-    let relativePath = import_node_path2.default.relative(ctx.rootDirectory, buildDirectory);
-    return !relativePath.startsWith("..") && !import_node_path2.default.isAbsolute(relativePath);
-  };
+    let relativePath = import_node_path2.default.relative(
+      ctx.rootDirectory,
+      buildDirectory,
+    )
+    return (
+      !relativePath.startsWith('..') &&
+      !import_node_path2.default.isAbsolute(relativePath)
+    )
+  }
   if (viteConfig.build.emptyOutDir ?? isWithinRoot()) {
-    await import_fs_extra.default.remove(buildDirectory);
+    await import_fs_extra.default.remove(buildDirectory)
   }
 }
 function getViteManifestPaths(ctx, serverBuilds) {
-  let buildRelative = (pathname) => import_node_path2.default.resolve(ctx.reactRouterConfig.buildDirectory, pathname);
+  let buildRelative = pathname =>
+    import_node_path2.default.resolve(
+      ctx.reactRouterConfig.buildDirectory,
+      pathname,
+    )
   let viteManifestPaths = [
-    "client/.vite/manifest.json",
+    'client/.vite/manifest.json',
     ...serverBuilds.map(({ serverBundleBuildConfig }) => {
-      let serverBundleId = serverBundleBuildConfig?.serverBundleId;
-      let serverBundlePath = serverBundleId ? serverBundleId + "/" : "";
-      return `server/${serverBundlePath}.vite/manifest.json`;
-    })
-  ].map((srcPath) => buildRelative(srcPath));
-  return viteManifestPaths;
+      let serverBundleId = serverBundleBuildConfig?.serverBundleId
+      let serverBundlePath = serverBundleId ? serverBundleId + '/' : ''
+      return `server/${serverBundlePath}.vite/manifest.json`
+    }),
+  ].map(srcPath => buildRelative(srcPath))
+  return viteManifestPaths
 }
-async function build(root, {
-  assetsInlineLimit,
-  clearScreen,
-  config: configFile,
-  emptyOutDir,
-  force,
-  logLevel,
-  minify,
-  mode,
-  sourcemapClient,
-  sourcemapServer
-}) {
-  await preloadViteEsm();
-  let viteConfig = await resolveViteConfig({ configFile, mode, root });
-  const ctx = await extractPluginContext(viteConfig);
+async function build(
+  root,
+  {
+    assetsInlineLimit,
+    clearScreen,
+    config: configFile,
+    emptyOutDir,
+    force,
+    logLevel,
+    minify,
+    mode,
+    sourcemapClient,
+    sourcemapServer,
+  },
+) {
+  await preloadViteEsm()
+  let viteConfig = await resolveViteConfig({ configFile, mode, root })
+  const ctx = await extractPluginContext(viteConfig)
   if (!ctx) {
     console.error(
-      import_picocolors5.default.red("React Router Vite plugin not found in Vite config")
-    );
-    process.exit(1);
+      import_picocolors5.default.red(
+        'React Router Vite plugin not found in Vite config',
+      ),
+    )
+    process.exit(1)
   }
-  let { reactRouterConfig } = ctx;
-  let vite2 = await import("vite");
-  async function viteBuild({
-    ssr,
-    serverBundleBuildConfig
-  }) {
+  let { reactRouterConfig } = ctx
+  let vite2 = await import('vite')
+  async function viteBuild({ ssr, serverBundleBuildConfig }) {
     await vite2.build({
       root,
       mode,
@@ -1208,72 +1361,78 @@ async function build(root, {
         emptyOutDir,
         minify,
         ssr,
-        sourcemap: ssr ? sourcemapServer : sourcemapClient
+        sourcemap: ssr ? sourcemapServer : sourcemapClient,
       },
       optimizeDeps: { force },
       clearScreen,
       logLevel,
-      ...serverBundleBuildConfig ? { __reactRouterServerBundleBuildConfig: serverBundleBuildConfig } : {}
-    });
+      ...(serverBundleBuildConfig
+        ? { __reactRouterServerBundleBuildConfig: serverBundleBuildConfig }
+        : {}),
+    })
   }
-  await cleanBuildDirectory(viteConfig, ctx);
-  await viteBuild({ ssr: false });
-  let { serverBuilds, buildManifest } = await getServerBuilds(ctx);
-  await Promise.all(serverBuilds.map(viteBuild));
-  let viteManifestPaths = getViteManifestPaths(ctx, serverBuilds);
+  await cleanBuildDirectory(viteConfig, ctx)
+  await viteBuild({ ssr: false })
+  let { serverBuilds, buildManifest } = await getServerBuilds(ctx)
+  await Promise.all(serverBuilds.map(viteBuild))
+  let viteManifestPaths = getViteManifestPaths(ctx, serverBuilds)
   await Promise.all(
-    viteManifestPaths.map(async (viteManifestPath) => {
-      let manifestExists = await import_fs_extra.default.pathExists(viteManifestPath);
-      if (!manifestExists) return;
+    viteManifestPaths.map(async viteManifestPath => {
+      let manifestExists =
+        await import_fs_extra.default.pathExists(viteManifestPath)
+      if (!manifestExists) return
       if (!ctx.viteManifestEnabled) {
-        await import_fs_extra.default.remove(viteManifestPath);
+        await import_fs_extra.default.remove(viteManifestPath)
       }
-      let viteDir = import_node_path2.default.dirname(viteManifestPath);
-      let viteDirFiles = await import_fs_extra.default.readdir(viteDir);
+      let viteDir = import_node_path2.default.dirname(viteManifestPath)
+      let viteDirFiles = await import_fs_extra.default.readdir(viteDir)
       if (viteDirFiles.length === 0) {
-        await import_fs_extra.default.remove(viteDir);
+        await import_fs_extra.default.remove(viteDir)
       }
-    })
-  );
+    }),
+  )
   await reactRouterConfig.buildEnd?.({
     buildManifest,
     reactRouterConfig,
-    viteConfig
-  });
+    viteConfig,
+  })
 }
-var import_node_path2, import_fs_extra, import_picocolors5;
+var import_node_path2, import_fs_extra, import_picocolors5
 var init_build = __esm({
-  "vite/build.ts"() {
-    "use strict";
-    import_node_path2 = __toESM(require("path"));
-    import_fs_extra = __toESM(require("fs-extra"));
-    import_picocolors5 = __toESM(require("picocolors"));
-    init_plugin();
-    init_config();
-    init_invariant();
-    init_import_vite_esm_sync();
-  }
-});
+  'vite/build.ts'() {
+    'use strict'
+    import_node_path2 = __toESM(require('path'))
+    import_fs_extra = __toESM(require('fs-extra'))
+    import_picocolors5 = __toESM(require('picocolors'))
+    init_plugin()
+    init_config()
+    init_invariant()
+    init_import_vite_esm_sync()
+  },
+})
 
 // vite/dev.ts
-var dev_exports = {};
+var dev_exports = {}
 __export(dev_exports, {
-  dev: () => dev
-});
-async function dev(root, {
-  clearScreen,
-  config: configFile,
-  cors,
-  force,
-  host,
-  logLevel,
-  mode,
-  open,
-  port,
-  strictPort
-}) {
-  await preloadViteEsm();
-  let vite2 = await import("vite");
+  dev: () => dev,
+})
+async function dev(
+  root,
+  {
+    clearScreen,
+    config: configFile,
+    cors,
+    force,
+    host,
+    logLevel,
+    mode,
+    open,
+    port,
+    strictPort,
+  },
+) {
+  await preloadViteEsm()
+  let vite2 = await import('vite')
   let server = await vite2.createServer({
     root,
     mode,
@@ -1281,70 +1440,72 @@ async function dev(root, {
     server: { open, cors, host, port, strictPort },
     optimizeDeps: { force },
     clearScreen,
-    logLevel
-  });
-  if (!server.config.plugins.find((plugin2) => plugin2.name === "react-router")) {
+    logLevel,
+  })
+  if (!server.config.plugins.find(plugin2 => plugin2.name === 'react-router')) {
     console.error(
-      import_picocolors6.default.red("React Router Vite plugin not found in Vite config")
-    );
-    process.exit(1);
+      import_picocolors6.default.red(
+        'React Router Vite plugin not found in Vite config',
+      ),
+    )
+    process.exit(1)
   }
-  await server.listen();
-  server.printUrls();
+  await server.listen()
+  server.printUrls()
   let customShortcuts = [
     {
-      key: "p",
-      description: "start/stop the profiler",
+      key: 'p',
+      description: 'start/stop the profiler',
       async action(server2) {
         if (getSession()) {
-          await stop(server2.config.logger.info);
+          await stop(server2.config.logger.info)
         } else {
           await start(() => {
-            server2.config.logger.info("Profiler started");
-          });
+            server2.config.logger.info('Profiler started')
+          })
         }
-      }
-    }
-  ];
-  server.bindCLIShortcuts({ print: true, customShortcuts });
+      },
+    },
+  ]
+  server.bindCLIShortcuts({ print: true, customShortcuts })
 }
-var import_picocolors6;
+var import_picocolors6
 var init_dev = __esm({
-  "vite/dev.ts"() {
-    "use strict";
-    import_picocolors6 = __toESM(require("picocolors"));
-    init_import_vite_esm_sync();
-    init_profiler();
-  }
-});
+  'vite/dev.ts'() {
+    'use strict'
+    import_picocolors6 = __toESM(require('picocolors'))
+    init_import_vite_esm_sync()
+    init_profiler()
+  },
+})
 
 // cli/run.ts
-var import_arg = __toESM(require("arg"));
-var import_semver = __toESM(require("semver"));
-var import_picocolors8 = __toESM(require("picocolors"));
+var import_arg = __toESM(require('arg'))
+var import_semver = __toESM(require('semver'))
+var import_picocolors8 = __toESM(require('picocolors'))
 
 // cli/commands.ts
-var path7 = __toESM(require("path"));
-var import_fs_extra2 = __toESM(require("fs-extra"));
-var import_package_json2 = __toESM(require("@npmcli/package-json"));
-var import_exit_hook = __toESM(require("exit-hook"));
-var import_picocolors7 = __toESM(require("picocolors"));
+var path7 = __toESM(require('path'))
+var import_fs_extra2 = __toESM(require('fs-extra'))
+var import_package_json2 = __toESM(require('@npmcli/package-json'))
+var import_exit_hook = __toESM(require('exit-hook'))
+var import_picocolors7 = __toESM(require('picocolors'))
 
 // config/format.ts
 function formatRoutes(routeManifest, format) {
   switch (format) {
-    case "json":
-      return formatRoutesAsJson(routeManifest);
-    case "jsx":
-      return formatRoutesAsJsx(routeManifest);
+    case 'json':
+      return formatRoutesAsJson(routeManifest)
+    case 'jsx':
+      return formatRoutesAsJsx(routeManifest)
   }
 }
 function formatRoutesAsJson(routeManifest) {
   function handleRoutesRecursive(parentId) {
     let routes2 = Object.values(routeManifest).filter(
-      (route) => route.parentId === parentId
-    );
-    let children = [];
+      route => route.parentId === parentId,
+    )
+    let children = []
     for (let route of routes2) {
       children.push({
         id: route.id,
@@ -1352,216 +1513,232 @@ function formatRoutesAsJson(routeManifest) {
         path: route.path,
         caseSensitive: route.caseSensitive,
         file: route.file,
-        children: handleRoutesRecursive(route.id)
-      });
+        children: handleRoutesRecursive(route.id),
+      })
     }
     if (children.length > 0) {
-      return children;
+      return children
     }
-    return void 0;
+    return void 0
   }
-  return JSON.stringify(handleRoutesRecursive() || null, null, 2);
+  return JSON.stringify(handleRoutesRecursive() || null, null, 2)
 }
 function formatRoutesAsJsx(routeManifest) {
-  let output = "<Routes>";
+  let output = '<Routes>'
   function handleRoutesRecursive(parentId, level = 1) {
     let routes2 = Object.values(routeManifest).filter(
-      (route) => route.parentId === parentId
-    );
-    let indent = Array(level * 2).fill(" ").join("");
+      route => route.parentId === parentId,
+    )
+    let indent = Array(level * 2)
+      .fill(' ')
+      .join('')
     for (let route of routes2) {
-      output += "\n" + indent;
-      output += `<Route${route.path ? ` path=${JSON.stringify(route.path)}` : ""}${route.index ? " index" : ""}${route.file ? ` file=${JSON.stringify(route.file)}` : ""}>`;
+      output += '\n' + indent
+      output += `<Route${route.path ? ` path=${JSON.stringify(route.path)}` : ''}${route.index ? ' index' : ''}${route.file ? ` file=${JSON.stringify(route.file)}` : ''}>`
       if (handleRoutesRecursive(route.id, level + 1)) {
-        output += "\n" + indent;
-        output += "</Route>";
+        output += '\n' + indent
+        output += '</Route>'
       } else {
-        output = output.slice(0, -1) + " />";
+        output = output.slice(0, -1) + ' />'
       }
     }
-    return routes2.length > 0;
+    return routes2.length > 0
   }
-  handleRoutesRecursive();
-  output += "\n</Routes>";
-  return output;
+  handleRoutesRecursive()
+  output += '\n</Routes>'
+  return output
 }
 
 // cli/commands.ts
-init_plugin();
+init_plugin()
 
 // cli/useJavascript.ts
-var babel2 = __toESM(require("@babel/core"));
-var import_plugin_syntax_jsx = __toESM(require("@babel/plugin-syntax-jsx"));
-var import_preset_typescript = __toESM(require("@babel/preset-typescript"));
-var import_prettier = __toESM(require("prettier"));
+var babel2 = __toESM(require('@babel/core'))
+var import_plugin_syntax_jsx = __toESM(require('@babel/plugin-syntax-jsx'))
+var import_preset_typescript = __toESM(require('@babel/preset-typescript'))
+var import_prettier = __toESM(require('prettier'))
 function transpile(tsx, options = {}) {
   let mjs = babel2.transformSync(tsx, {
     compact: false,
     cwd: options.cwd,
     filename: options.filename,
     plugins: [import_plugin_syntax_jsx.default],
-    presets: [[import_preset_typescript.default, { jsx: "preserve" }]],
-    retainLines: true
-  });
-  if (!mjs || !mjs.code) throw new Error("Could not parse TypeScript");
-  return import_prettier.default.format(mjs.code, { parser: "babel" });
+    presets: [[import_preset_typescript.default, { jsx: 'preserve' }]],
+    retainLines: true,
+  })
+  if (!mjs || !mjs.code) throw new Error('Could not parse TypeScript')
+  return import_prettier.default.format(mjs.code, { parser: 'babel' })
 }
 
 // cli/commands.ts
-init_profiler();
-init_typegen();
-init_import_vite_esm_sync();
+init_profiler()
+init_typegen()
+init_import_vite_esm_sync()
 async function routes(reactRouterRoot, flags = {}) {
   let ctx = await loadPluginContext({
     root: reactRouterRoot,
-    configFile: flags.config
-  });
+    configFile: flags.config,
+  })
   if (!ctx) {
     console.error(
-      import_picocolors7.default.red("React Router Vite plugin not found in Vite config")
-    );
-    process.exit(1);
+      import_picocolors7.default.red(
+        'React Router Vite plugin not found in Vite config',
+      ),
+    )
+    process.exit(1)
   }
-  let format = flags.json ? "json" : "jsx";
-  console.log(formatRoutes(ctx.reactRouterConfig.routes, format));
+  let format = flags.json ? 'json' : 'jsx'
+  console.log(formatRoutes(ctx.reactRouterConfig.routes, format))
 }
 async function build2(root, options = {}) {
   if (!root) {
-    root = process.env.REACT_ROUTER_ROOT || process.cwd();
+    root = process.env.REACT_ROUTER_ROOT || process.cwd()
   }
-  let { build: build3 } = await Promise.resolve().then(() => (init_build(), build_exports));
+  let { build: build3 } = await Promise.resolve().then(
+    () => (init_build(), build_exports),
+  )
   if (options.profile) {
-    await start();
+    await start()
   }
   try {
-    await build3(root, options);
+    await build3(root, options)
   } finally {
-    await stop(console.info);
+    await stop(console.info)
   }
 }
 async function dev2(root, options = {}) {
-  let { dev: dev3 } = await Promise.resolve().then(() => (init_dev(), dev_exports));
+  let { dev: dev3 } = await Promise.resolve().then(
+    () => (init_dev(), dev_exports),
+  )
   if (options.profile) {
-    await start();
+    await start()
   }
-  (0, import_exit_hook.default)(() => stop(console.info));
-  await dev3(root, options);
-  await new Promise(() => {
-  });
+  ;(0, import_exit_hook.default)(() => stop(console.info))
+  await dev3(root, options)
+  await new Promise(() => {})
 }
-var clientEntries = ["entry.client.tsx", "entry.client.js", "entry.client.jsx"];
-var serverEntries = ["entry.server.tsx", "entry.server.js", "entry.server.jsx"];
-var entries = ["entry.client", "entry.server"];
-var conjunctionListFormat = new Intl.ListFormat("en", {
-  style: "long",
-  type: "conjunction"
-});
+var clientEntries = ['entry.client.tsx', 'entry.client.js', 'entry.client.jsx']
+var serverEntries = ['entry.server.tsx', 'entry.server.js', 'entry.server.jsx']
+var entries = ['entry.client', 'entry.server']
+var conjunctionListFormat = new Intl.ListFormat('en', {
+  style: 'long',
+  type: 'conjunction',
+})
 async function generateEntry(entry, reactRouterRoot, flags = {}) {
   let ctx = await loadPluginContext({
     root: reactRouterRoot,
-    configFile: flags.config
-  });
-  let rootDirectory = ctx.rootDirectory;
-  let appDirectory = ctx.reactRouterConfig.appDirectory;
+    configFile: flags.config,
+  })
+  let rootDirectory = ctx.rootDirectory
+  let appDirectory = ctx.reactRouterConfig.appDirectory
   if (!entry) {
-    await generateEntry("entry.client", reactRouterRoot, flags);
-    await generateEntry("entry.server", reactRouterRoot, flags);
-    return;
+    await generateEntry('entry.client', reactRouterRoot, flags)
+    await generateEntry('entry.server', reactRouterRoot, flags)
+    return
   }
   if (!entries.includes(entry)) {
-    let entriesArray = Array.from(entries);
-    let list = conjunctionListFormat.format(entriesArray);
+    let entriesArray = Array.from(entries)
+    let list = conjunctionListFormat.format(entriesArray)
     console.error(
-      import_picocolors7.default.red(`Invalid entry file. Valid entry files are ${list}`)
-    );
-    return;
+      import_picocolors7.default.red(
+        `Invalid entry file. Valid entry files are ${list}`,
+      ),
+    )
+    return
   }
-  let pkgJson = await import_package_json2.default.load(rootDirectory);
-  let deps = pkgJson.content.dependencies ?? {};
-  if (!deps["@react-router/node"]) {
-    console.error(import_picocolors7.default.red(`No default server entry detected.`));
-    return;
+  let pkgJson = await import_package_json2.default.load(rootDirectory)
+  let deps = pkgJson.content.dependencies ?? {}
+  if (!deps['@react-router/node']) {
+    console.error(
+      import_picocolors7.default.red(`No default server entry detected.`),
+    )
+    return
   }
   let defaultsDirectory = path7.resolve(
-    path7.dirname(require.resolve("@react-router/dev/package.json")),
-    "dist",
-    "config",
-    "defaults"
-  );
-  let defaultEntryClient = path7.resolve(defaultsDirectory, "entry.client.tsx");
+    path7.dirname(require.resolve('@react-router/dev/package.json')),
+    'dist',
+    'config',
+    'defaults',
+  )
+  let defaultEntryClient = path7.resolve(defaultsDirectory, 'entry.client.tsx')
   let defaultEntryServer = path7.resolve(
     defaultsDirectory,
-    `entry.server.node.tsx`
-  );
-  let isServerEntry = entry === "entry.server";
-  let contents = isServerEntry ? await createServerEntry(rootDirectory, appDirectory, defaultEntryServer) : await createClientEntry(rootDirectory, appDirectory, defaultEntryClient);
-  let useTypeScript = flags.typescript ?? true;
-  let outputExtension = useTypeScript ? "tsx" : "jsx";
-  let outputEntry = `${entry}.${outputExtension}`;
-  let outputFile2 = path7.resolve(appDirectory, outputEntry);
+    `entry.server.node.tsx`,
+  )
+  let isServerEntry = entry === 'entry.server'
+  let contents = isServerEntry
+    ? await createServerEntry(rootDirectory, appDirectory, defaultEntryServer)
+    : await createClientEntry(rootDirectory, appDirectory, defaultEntryClient)
+  let useTypeScript = flags.typescript ?? true
+  let outputExtension = useTypeScript ? 'tsx' : 'jsx'
+  let outputEntry = `${entry}.${outputExtension}`
+  let outputFile2 = path7.resolve(appDirectory, outputEntry)
   if (!useTypeScript) {
     let javascript = transpile(contents, {
       cwd: rootDirectory,
-      filename: isServerEntry ? defaultEntryServer : defaultEntryClient
-    });
-    await import_fs_extra2.default.writeFile(outputFile2, javascript, "utf-8");
+      filename: isServerEntry ? defaultEntryServer : defaultEntryClient,
+    })
+    await import_fs_extra2.default.writeFile(outputFile2, javascript, 'utf-8')
   } else {
-    await import_fs_extra2.default.writeFile(outputFile2, contents, "utf-8");
+    await import_fs_extra2.default.writeFile(outputFile2, contents, 'utf-8')
   }
   console.log(
     import_picocolors7.default.blue(
       `Entry file ${entry} created at ${path7.relative(
         rootDirectory,
-        outputFile2
-      )}.`
-    )
-  );
+        outputFile2,
+      )}.`,
+    ),
+  )
 }
 async function checkForEntry(rootDirectory, appDirectory, entries2) {
   for (let entry of entries2) {
-    let entryPath = path7.resolve(appDirectory, entry);
-    let exists = await import_fs_extra2.default.pathExists(entryPath);
+    let entryPath = path7.resolve(appDirectory, entry)
+    let exists = await import_fs_extra2.default.pathExists(entryPath)
     if (exists) {
-      let relative8 = path7.relative(rootDirectory, entryPath);
-      console.error(import_picocolors7.default.red(`Entry file ${relative8} already exists.`));
-      return process.exit(1);
+      let relative8 = path7.relative(rootDirectory, entryPath)
+      console.error(
+        import_picocolors7.default.red(
+          `Entry file ${relative8} already exists.`,
+        ),
+      )
+      return process.exit(1)
     }
   }
 }
 async function createServerEntry(rootDirectory, appDirectory, inputFile) {
-  await checkForEntry(rootDirectory, appDirectory, serverEntries);
-  let contents = await import_fs_extra2.default.readFile(inputFile, "utf-8");
-  return contents;
+  await checkForEntry(rootDirectory, appDirectory, serverEntries)
+  let contents = await import_fs_extra2.default.readFile(inputFile, 'utf-8')
+  return contents
 }
 async function createClientEntry(rootDirectory, appDirectory, inputFile) {
-  await checkForEntry(rootDirectory, appDirectory, clientEntries);
-  let contents = await import_fs_extra2.default.readFile(inputFile, "utf-8");
-  return contents;
+  await checkForEntry(rootDirectory, appDirectory, clientEntries)
+  let contents = await import_fs_extra2.default.readFile(inputFile, 'utf-8')
+  return contents
 }
 async function typegen(root, flags) {
-  root ??= process.cwd();
+  root ??= process.cwd()
   if (flags.watch) {
-    await preloadViteEsm();
-    const vite2 = importViteEsmSync();
-    const logger = vite2.createLogger("info", { prefix: "[react-router]" });
-    await watch(root, { logger });
-    await new Promise(() => {
-    });
-    return;
-  }
-  await run(root);
+    await preloadViteEsm()
+    const vite2 = importViteEsmSync()
+    const logger = vite2.createLogger('info', { prefix: '[react-router]' })
+    await watch(root, { logger })
+    await new Promise(() => {})
+    return
+  }
+  await run(root)
 }
 
 // cli/run.ts
 var helpText = `
-${import_picocolors8.default.blueBright("react-router")}
+${import_picocolors8.default.blueBright('react-router')}
 
-  ${import_picocolors8.default.underline("Usage")}:
-    $ react-router build [${import_picocolors8.default.yellowBright("projectDir")}]
-    $ react-router dev [${import_picocolors8.default.yellowBright("projectDir")}]
-    $ react-router routes [${import_picocolors8.default.yellowBright("projectDir")}]
+  ${import_picocolors8.default.underline('Usage')}:
+    $ react-router build [${import_picocolors8.default.yellowBright('projectDir')}]
+    $ react-router dev [${import_picocolors8.default.yellowBright('projectDir')}]
+    $ react-router routes [${import_picocolors8.default.yellowBright('projectDir')}]
 
-  ${import_picocolors8.default.underline("Options")}:
+  ${import_picocolors8.default.underline('Options')}:
     --help, -h          Print this help message and exit
     --version, -v       Print the CLI version and exit
     --no-color          Disable ANSI colors in console output
@@ -1597,22 +1774,22 @@ ${import_picocolors8.default.blueBright("react-router")}
   \`typegen\` Options:
     --watch             Automatically regenerate types whenever route config (\`routes.ts\`) or route modules change
 
-  ${import_picocolors8.default.underline("Build your project")}:
+  ${import_picocolors8.default.underline('Build your project')}:
 
     $ react-router build
 
-  ${import_picocolors8.default.underline("Run your project locally in development")}:
+  ${import_picocolors8.default.underline('Run your project locally in development')}:
 
     $ react-router dev
 
-  ${import_picocolors8.default.underline("Show all routes in your app")}:
+  ${import_picocolors8.default.underline('Show all routes in your app')}:
 
     $ react-router routes
     $ react-router routes my-app
     $ react-router routes --json
     $ react-router routes --config vite.react-router.config.ts
 
-  ${import_picocolors8.default.underline("Reveal the used entry point")}:
+  ${import_picocolors8.default.underline('Reveal the used entry point')}:
 
     $ react-router reveal entry.client
     $ react-router reveal entry.server
@@ -1620,109 +1797,117 @@ ${import_picocolors8.default.blueBright("react-router")}
     $ react-router reveal entry.server --no-typescript
     $ react-router reveal entry.server --config vite.react-router.config.ts
 
-  ${import_picocolors8.default.underline("Generate types for route modules")}:
+  ${import_picocolors8.default.underline('Generate types for route modules')}:
 
    $ react-router typegen
    $ react-router typegen --watch
-`;
+`
 async function run2(argv = process.argv.slice(2)) {
-  let versions = process.versions;
-  let MINIMUM_NODE_VERSION = 20;
-  if (versions && versions.node && import_semver.default.major(versions.node) < MINIMUM_NODE_VERSION) {
+  let versions = process.versions
+  let MINIMUM_NODE_VERSION = 20
+  if (
+    versions &&
+    versions.node &&
+    import_semver.default.major(versions.node) < MINIMUM_NODE_VERSION
+  ) {
     console.warn(
-      `\uFE0F\u26A0\uFE0F Oops, Node v${versions.node} detected. react-router requires a Node version greater than ${MINIMUM_NODE_VERSION}.`
-    );
+      `\uFE0F\u26A0\uFE0F Oops, Node v${versions.node} detected. react-router requires a Node version greater than ${MINIMUM_NODE_VERSION}.`,
+    )
+  }
+  let isBooleanFlag = arg2 => {
+    let index = argv.indexOf(arg2)
+    let nextArg = argv[index + 1]
+    return !nextArg || nextArg.startsWith('-')
   }
-  let isBooleanFlag = (arg2) => {
-    let index = argv.indexOf(arg2);
-    let nextArg = argv[index + 1];
-    return !nextArg || nextArg.startsWith("-");
-  };
   let args = (0, import_arg.default)(
     {
-      "--force": Boolean,
-      "--help": Boolean,
-      "-h": "--help",
-      "--json": Boolean,
-      "--token": String,
-      "--typescript": Boolean,
-      "--no-typescript": Boolean,
-      "--version": Boolean,
-      "-v": "--version",
-      "--port": Number,
-      "-p": "--port",
-      "--config": String,
-      "-c": "--config",
-      "--assetsInlineLimit": Number,
-      "--clearScreen": Boolean,
-      "--cors": Boolean,
-      "--emptyOutDir": Boolean,
-      "--host": isBooleanFlag("--host") ? Boolean : String,
-      "--logLevel": String,
-      "-l": "--logLevel",
-      "--minify": String,
-      "--mode": String,
-      "-m": "--mode",
-      "--open": isBooleanFlag("--open") ? Boolean : String,
-      "--strictPort": Boolean,
-      "--profile": Boolean,
-      "--sourcemapClient": isBooleanFlag("--sourcemapClient") ? Boolean : String,
-      "--sourcemapServer": isBooleanFlag("--sourcemapServer") ? Boolean : String,
-      "--watch": Boolean
+      '--force': Boolean,
+      '--help': Boolean,
+      '-h': '--help',
+      '--json': Boolean,
+      '--token': String,
+      '--typescript': Boolean,
+      '--no-typescript': Boolean,
+      '--version': Boolean,
+      '-v': '--version',
+      '--port': Number,
+      '-p': '--port',
+      '--config': String,
+      '-c': '--config',
+      '--assetsInlineLimit': Number,
+      '--clearScreen': Boolean,
+      '--cors': Boolean,
+      '--emptyOutDir': Boolean,
+      '--host': isBooleanFlag('--host') ? Boolean : String,
+      '--logLevel': String,
+      '-l': '--logLevel',
+      '--minify': String,
+      '--mode': String,
+      '-m': '--mode',
+      '--open': isBooleanFlag('--open') ? Boolean : String,
+      '--strictPort': Boolean,
+      '--profile': Boolean,
+      '--sourcemapClient': isBooleanFlag('--sourcemapClient')
+        ? Boolean
+        : String,
+      '--sourcemapServer': isBooleanFlag('--sourcemapServer')
+        ? Boolean
+        : String,
+      '--watch': Boolean,
     },
     {
-      argv
-    }
-  );
-  let input = args._;
+      argv,
+    },
+  )
+  let input = args._
   let flags = Object.entries(args).reduce((acc, [key, value]) => {
-    key = key.replace(/^--/, "");
-    acc[key] = value;
-    return acc;
-  }, {});
+    key = key.replace(/^--/, '')
+    acc[key] = value
+    return acc
+  }, {})
   if (flags.help) {
-    console.log(helpText);
-    return;
+    console.log(helpText)
+    return
   }
   if (flags.version) {
-    let version = require("../package.json").version;
-    console.log(version);
-    return;
+    let version = require('../package.json').version
+    console.log(version)
+    return
   }
-  flags.interactive = flags.interactive ?? require.main === module;
-  if (args["--no-typescript"]) {
-    flags.typescript = false;
+  flags.interactive = flags.interactive ?? require.main === module
+  if (args['--no-typescript']) {
+    flags.typescript = false
   }
-  let command = input[0];
+  let command = input[0]
   switch (command) {
-    case "routes":
-      await routes(input[1], flags);
-      break;
-    case "build":
-      await build2(input[1], flags);
-      break;
-    case "reveal": {
-      await generateEntry(input[1], input[2], flags);
-      break;
+    case 'routes':
+      await routes(input[1], flags)
+      break
+    case 'build':
+      await build2(input[1], flags)
+      break
+    case 'reveal': {
+      await generateEntry(input[1], input[2], flags)
+      break
     }
-    case "dev":
-      await dev2(input[1], flags);
-      break;
-    case "typegen":
-      await typegen(input[1], flags);
-      break;
+    case 'dev':
+      await dev2(input[1], flags)
+      break
+    case 'typegen':
+      await typegen(input[1], flags)
+      break
     default:
-      await dev2(input[0], flags);
+      await dev2(input[0], flags)
   }
 }
 
 // cli/index.ts
 run2().then(
   () => {
-    process.exit(0);
+    process.exit(0)
   },
-  (error) => {
-    if (error) console.error(error);
-    process.exit(1);
-  }
-);
+  error => {
+    if (error) console.error(error)
+    process.exit(1)
+  },
+)
diff --git a/node_modules/@react-router/dev/dist/vite.js b/node_modules/@react-router/dev/dist/vite.js
index f17d1b6..399253a 100644
--- a/node_modules/@react-router/dev/dist/vite.js
+++ b/node_modules/@react-router/dev/dist/vite.js
@@ -8,340 +8,372 @@
  *
  * @license MIT
  */
-"use strict";
-var __create = Object.create;
-var __defProp = Object.defineProperty;
-var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
-var __getOwnPropNames = Object.getOwnPropertyNames;
-var __getProtoOf = Object.getPrototypeOf;
-var __hasOwnProp = Object.prototype.hasOwnProperty;
+'use strict'
+var __create = Object.create
+var __defProp = Object.defineProperty
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor
+var __getOwnPropNames = Object.getOwnPropertyNames
+var __getProtoOf = Object.getPrototypeOf
+var __hasOwnProp = Object.prototype.hasOwnProperty
 var __export = (target, all) => {
   for (var name in all)
-    __defProp(target, name, { get: all[name], enumerable: true });
-};
+    __defProp(target, name, { get: all[name], enumerable: true })
+}
 var __copyProps = (to, from, except, desc) => {
-  if (from && typeof from === "object" || typeof from === "function") {
+  if ((from && typeof from === 'object') || typeof from === 'function') {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
-        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
-  }
-  return to;
-};
-var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  // If the importer is in node compatibility mode or this is not an ESM
-  // file that has been converted to a CommonJS file using a Babel-
-  // compatible transform (i.e. "__esModule" has not been set), then set
-  // "default" to the CommonJS "module.exports" for node compatibility.
-  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-  mod
-));
-var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+        __defProp(to, key, {
+          get: () => from[key],
+          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
+        })
+  }
+  return to
+}
+var __toESM = (mod, isNodeMode, target) => (
+  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
+  __copyProps(
+    // If the importer is in node compatibility mode or this is not an ESM
+    // file that has been converted to a CommonJS file using a Babel-
+    // compatible transform (i.e. "__esModule" has not been set), then set
+    // "default" to the CommonJS "module.exports" for node compatibility.
+    isNodeMode || !mod || !mod.__esModule
+      ? __defProp(target, 'default', { value: mod, enumerable: true })
+      : target,
+    mod,
+  )
+)
+var __toCommonJS = mod =>
+  __copyProps(__defProp({}, '__esModule', { value: true }), mod)
 
 // vite.ts
-var vite_exports = {};
+var vite_exports = {}
 __export(vite_exports, {
-  reactRouter: () => reactRouterVitePlugin
-});
-module.exports = __toCommonJS(vite_exports);
+  reactRouter: () => reactRouterVitePlugin,
+})
+module.exports = __toCommonJS(vite_exports)
 
 // vite/plugin.ts
-var import_node_crypto = require("crypto");
-var path4 = __toESM(require("path"));
-var url2 = __toESM(require("url"));
-var fse = __toESM(require("fs-extra"));
-var babel = __toESM(require("@babel/core"));
-var import_react_router2 = require("react-router");
-var import_es_module_lexer = require("es-module-lexer");
-var import_jsesc = __toESM(require("jsesc"));
-var import_picocolors3 = __toESM(require("picocolors"));
+var import_node_crypto = require('crypto')
+var path4 = __toESM(require('path'))
+var url2 = __toESM(require('url'))
+var fse = __toESM(require('fs-extra'))
+var babel = __toESM(require('@babel/core'))
+var import_react_router2 = require('react-router')
+var import_es_module_lexer = require('es-module-lexer')
+var import_jsesc = __toESM(require('jsesc'))
+var import_picocolors3 = __toESM(require('picocolors'))
 
 // typegen/index.ts
-var import_node_fs2 = __toESM(require("fs"));
-var Path4 = __toESM(require("pathe"));
-var import_picocolors2 = __toESM(require("picocolors"));
+var import_node_fs2 = __toESM(require('fs'))
+var Path4 = __toESM(require('pathe'))
+var import_picocolors2 = __toESM(require('picocolors'))
 
 // config/config.ts
-var import_node_fs = __toESM(require("fs"));
-var import_node_child_process = require("child_process");
-var import_package_json = __toESM(require("@npmcli/package-json"));
+var import_node_fs = __toESM(require('fs'))
+var import_node_child_process = require('child_process')
+var import_package_json = __toESM(require('@npmcli/package-json'))
 
 // vite/vite-node.ts
-var import_server = require("vite-node/server");
-var import_client = require("vite-node/client");
-var import_source_map = require("vite-node/source-map");
+var import_server = require('vite-node/server')
+var import_client = require('vite-node/client')
+var import_source_map = require('vite-node/source-map')
 
 // invariant.ts
 function invariant(value, message) {
-  if (value === false || value === null || typeof value === "undefined") {
+  if (value === false || value === null || typeof value === 'undefined') {
     console.error(
-      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
-    );
-    throw new Error(message);
+      'The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose',
+    )
+    throw new Error(message)
   }
 }
 
 // vite/import-vite-esm-sync.ts
-var vite;
+var vite
 async function preloadViteEsm() {
-  vite = await import("vite");
+  vite = await import('vite')
 }
 function importViteEsmSync() {
-  invariant(vite, "importViteEsmSync() called before preloadViteEsm()");
-  return vite;
+  invariant(vite, 'importViteEsmSync() called before preloadViteEsm()')
+  return vite
 }
 
 // vite/vite-node.ts
 async function createContext(viteConfig = {}) {
-  await preloadViteEsm();
-  const vite2 = importViteEsmSync();
+  await preloadViteEsm()
+  const vite2 = importViteEsmSync()
   const devServer = await vite2.createServer(
     vite2.mergeConfig(
       {
         server: {
           preTransformRequests: false,
-          hmr: false
+          hmr: false,
         },
         optimizeDeps: {
-          noDiscovery: true
+          noDiscovery: true,
         },
         configFile: false,
         envFile: false,
-        plugins: []
+        plugins: [],
       },
-      viteConfig
-    )
-  );
-  await devServer.pluginContainer.buildStart({});
-  const server = new import_server.ViteNodeServer(devServer);
-  (0, import_source_map.installSourcemapsSupport)({
-    getSourceMap: (source) => server.getSourceMap(source)
-  });
+      viteConfig,
+    ),
+  )
+  await devServer.pluginContainer.buildStart({})
+  const server = new import_server.ViteNodeServer(devServer)
+  ;(0, import_source_map.installSourcemapsSupport)({
+    getSourceMap: source => server.getSourceMap(source),
+  })
   const runner = new import_client.ViteNodeRunner({
     root: devServer.config.root,
     base: devServer.config.base,
     fetchModule(id2) {
-      return server.fetchModule(id2);
+      return server.fetchModule(id2)
     },
     resolveId(id2, importer) {
-      return server.resolveId(id2, importer);
-    }
-  });
-  return { devServer, server, runner };
+      return server.resolveId(id2, importer)
+    },
+  })
+  return { devServer, server, runner }
 }
 
 // config/config.ts
-var import_pathe = __toESM(require("pathe"));
-var import_chokidar = __toESM(require("chokidar"));
-var import_picocolors = __toESM(require("picocolors"));
-var import_pick2 = __toESM(require("lodash/pick"));
-var import_omit = __toESM(require("lodash/omit"));
-var import_cloneDeep = __toESM(require("lodash/cloneDeep"));
-var import_isEqual = __toESM(require("lodash/isEqual"));
+var import_pathe = __toESM(require('pathe'))
+var import_chokidar = __toESM(require('chokidar'))
+var import_picocolors = __toESM(require('picocolors'))
+var import_pick2 = __toESM(require('lodash/pick'))
+var import_omit = __toESM(require('lodash/omit'))
+var import_cloneDeep = __toESM(require('lodash/cloneDeep'))
+var import_isEqual = __toESM(require('lodash/isEqual'))
 
 // config/routes.ts
-var Path = __toESM(require("pathe"));
-var v = __toESM(require("valibot"));
-var import_pick = __toESM(require("lodash/pick"));
+var Path = __toESM(require('pathe'))
+var v = __toESM(require('valibot'))
+var import_pick = __toESM(require('lodash/pick'))
 function setAppDirectory(directory) {
-  globalThis.__reactRouterAppDirectory = directory;
+  globalThis.__reactRouterAppDirectory = directory
 }
 var routeConfigEntrySchema = v.pipe(
-  v.custom((value) => {
-    return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
-  }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
+  v.custom(value => {
+    return !(
+      typeof value === 'object' &&
+      value !== null &&
+      'then' in value &&
+      'catch' in value
+    )
+  }, 'Invalid type: Expected object but received a promise. Did you forget to await?'),
   v.object({
     id: v.optional(v.string()),
     path: v.optional(v.string()),
     index: v.optional(v.boolean()),
     caseSensitive: v.optional(v.boolean()),
     file: v.string(),
-    children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
-  })
-);
-var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
-function validateRouteConfig({
-  routeConfigFile,
-  routeConfig
-}) {
+    children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema))),
+  }),
+)
+var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema)
+function validateRouteConfig({ routeConfigFile, routeConfig }) {
   if (!routeConfig) {
     return {
       valid: false,
-      message: `Route config must be the default export in "${routeConfigFile}".`
-    };
+      message: `Route config must be the default export in "${routeConfigFile}".`,
+    }
   }
   if (!Array.isArray(routeConfig)) {
     return {
       valid: false,
-      message: `Route config in "${routeConfigFile}" must be an array.`
-    };
+      message: `Route config in "${routeConfigFile}" must be an array.`,
+    }
   }
-  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
+  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig)
   if (issues?.length) {
-    let { root, nested } = v.flatten(issues);
+    let { root, nested } = v.flatten(issues)
     return {
       valid: false,
       message: [
         `Route config in "${routeConfigFile}" is invalid.`,
         root ? `${root}` : [],
-        nested ? Object.entries(nested).map(
-          ([path5, message]) => `Path: routes.${path5}
-${message}`
-        ) : []
-      ].flat().join("\n\n")
-    };
+        nested
+          ? Object.entries(nested).map(
+              ([path5, message]) => `Path: routes.${path5}
+${message}`,
+            )
+          : [],
+      ]
+        .flat()
+        .join('\n\n'),
+    }
   }
-  return { valid: true };
+  return { valid: true }
 }
-function configRoutesToRouteManifest(appDirectory, routes, rootId = "root") {
-  let routeManifest = {};
+function configRoutesToRouteManifest(appDirectory, routes, rootId = 'root') {
+  let routeManifest = {}
   function walk(route, parentId) {
-    let id2 = route.id || createRouteId(route.file);
+    let id2 = route.id || createRouteId(route.file)
     let manifestItem = {
       id: id2,
       parentId,
-      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
+      file: Path.isAbsolute(route.file)
+        ? Path.relative(appDirectory, route.file)
+        : route.file,
       path: route.path,
       index: route.index,
-      caseSensitive: route.caseSensitive
-    };
+      caseSensitive: route.caseSensitive,
+    }
     if (routeManifest.hasOwnProperty(id2)) {
       throw new Error(
-        `Unable to define routes with duplicate route id: "${id2}"`
-      );
+        `Unable to define routes with duplicate route id: "${id2}"`,
+      )
     }
-    routeManifest[id2] = manifestItem;
+    routeManifest[id2] = manifestItem
     if (route.children) {
       for (let child of route.children) {
-        walk(child, id2);
+        walk(child, id2)
       }
     }
   }
   for (let route of routes) {
-    walk(route, rootId);
+    walk(route, rootId)
   }
-  return routeManifest;
+  return routeManifest
 }
 function createRouteId(file) {
-  return Path.normalize(stripFileExtension(file));
+  return Path.normalize(stripFileExtension(file))
 }
 function stripFileExtension(file) {
-  return file.replace(/\.[a-z0-9]+$/i, "");
+  return file.replace(/\.[a-z0-9]+$/i, '')
 }
 
 // cli/detectPackageManager.ts
 var detectPackageManager = () => {
-  let { npm_config_user_agent } = process.env;
-  if (!npm_config_user_agent) return void 0;
+  let { npm_config_user_agent } = process.env
+  if (!npm_config_user_agent) return void 0
   try {
-    let pkgManager = npm_config_user_agent.split("/")[0];
-    if (pkgManager === "npm") return "npm";
-    if (pkgManager === "pnpm") return "pnpm";
-    if (pkgManager === "yarn") return "yarn";
-    if (pkgManager === "bun") return "bun";
-    return void 0;
+    let pkgManager = npm_config_user_agent.split('/')[0]
+    if (pkgManager === 'npm') return 'npm'
+    if (pkgManager === 'pnpm') return 'pnpm'
+    if (pkgManager === 'yarn') return 'yarn'
+    if (pkgManager === 'bun') return 'bun'
+    return void 0
   } catch {
-    return void 0;
+    return void 0
   }
-};
+}
 
 // config/config.ts
-var excludedConfigPresetKeys = ["presets"];
+var excludedConfigPresetKeys = ['presets']
 var mergeReactRouterConfig = (...configs) => {
   let reducer = (configA, configB) => {
-    let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
+    let mergeRequired = key =>
+      configA[key] !== void 0 && configB[key] !== void 0
     return {
       ...configA,
       ...configB,
-      ...mergeRequired("buildEnd") ? {
-        buildEnd: async (...args) => {
-          await Promise.all([
-            configA.buildEnd?.(...args),
-            configB.buildEnd?.(...args)
-          ]);
-        }
-      } : {},
-      ...mergeRequired("future") ? {
-        future: {
-          ...configA.future,
-          ...configB.future
-        }
-      } : {},
-      ...mergeRequired("presets") ? {
-        presets: [...configA.presets ?? [], ...configB.presets ?? []]
-      } : {}
-    };
-  };
-  return configs.reduce(reducer, {});
-};
-var deepFreeze = (o) => {
-  Object.freeze(o);
-  let oIsFunction = typeof o === "function";
-  let hasOwnProp = Object.prototype.hasOwnProperty;
-  Object.getOwnPropertyNames(o).forEach(function(prop) {
-    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
-      deepFreeze(o[prop]);
+      ...(mergeRequired('buildEnd')
+        ? {
+            buildEnd: async (...args) => {
+              await Promise.all([
+                configA.buildEnd?.(...args),
+                configB.buildEnd?.(...args),
+              ])
+            },
+          }
+        : {}),
+      ...(mergeRequired('future')
+        ? {
+            future: {
+              ...configA.future,
+              ...configB.future,
+            },
+          }
+        : {}),
+      ...(mergeRequired('presets')
+        ? {
+            presets: [...(configA.presets ?? []), ...(configB.presets ?? [])],
+          }
+        : {}),
     }
-  });
-  return o;
-};
+  }
+  return configs.reduce(reducer, {})
+}
+var deepFreeze = o => {
+  Object.freeze(o)
+  let oIsFunction = typeof o === 'function'
+  let hasOwnProp = Object.prototype.hasOwnProperty
+  Object.getOwnPropertyNames(o).forEach(function (prop) {
+    if (
+      hasOwnProp.call(o, prop) &&
+      (oIsFunction
+        ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'
+        : true) &&
+      o[prop] !== null &&
+      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
+      !Object.isFrozen(o[prop])
+    ) {
+      deepFreeze(o[prop])
+    }
+  })
+  return o
+}
 function ok(value) {
-  return { ok: true, value };
+  return { ok: true, value }
 }
 function err(error) {
-  return { ok: false, error };
-}
-async function resolveConfig({
-  root,
-  viteNodeContext,
-  reactRouterConfigFile
-}) {
-  let reactRouterUserConfig = {};
+  return { ok: false, error }
+}
+async function resolveConfig({ root, viteNodeContext, reactRouterConfigFile }) {
+  let reactRouterUserConfig = {}
   if (reactRouterConfigFile) {
     try {
       if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
-        return err(`${reactRouterConfigFile} no longer exists`);
+        return err(`${reactRouterConfigFile} no longer exists`)
       }
       let configModule = await viteNodeContext.runner.executeFile(
-        reactRouterConfigFile
-      );
+        reactRouterConfigFile,
+      )
       if (configModule.default === void 0) {
-        return err(`${reactRouterConfigFile} must provide a default export`);
+        return err(`${reactRouterConfigFile} must provide a default export`)
       }
-      if (typeof configModule.default !== "object") {
-        return err(`${reactRouterConfigFile} must export a config`);
+      if (typeof configModule.default !== 'object') {
+        return err(`${reactRouterConfigFile} must export a config`)
       }
-      reactRouterUserConfig = configModule.default;
+      reactRouterUserConfig = configModule.default
     } catch (error) {
-      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
+      return err(`Error loading ${reactRouterConfigFile}: ${error}`)
     }
   }
-  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
-  let presets = (await Promise.all(
-    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
-      if (!preset.name) {
-        throw new Error(
-          "React Router presets must have a `name` property defined."
-        );
-      }
-      if (!preset.reactRouterConfig) {
-        return null;
-      }
-      let configPreset = (0, import_omit.default)(
-        await preset.reactRouterConfig({ reactRouterUserConfig }),
-        excludedConfigPresetKeys
-      );
-      return configPreset;
-    })
-  )).filter(function isNotNull(value) {
-    return value !== null;
-  });
+  reactRouterUserConfig = deepFreeze(
+    (0, import_cloneDeep.default)(reactRouterUserConfig),
+  )
+  let presets = (
+    await Promise.all(
+      (reactRouterUserConfig.presets ?? []).map(async preset => {
+        if (!preset.name) {
+          throw new Error(
+            'React Router presets must have a `name` property defined.',
+          )
+        }
+        if (!preset.reactRouterConfig) {
+          return null
+        }
+        let configPreset = (0, import_omit.default)(
+          await preset.reactRouterConfig({ reactRouterUserConfig }),
+          excludedConfigPresetKeys,
+        )
+        return configPreset
+      }),
+    )
+  ).filter(function isNotNull(value) {
+    return value !== null
+  })
   let defaults = {
-    basename: "/",
-    buildDirectory: "build",
-    serverBuildFile: "index.js",
-    serverModuleFormat: "esm",
-    ssr: true
-  };
+    basename: '/',
+    buildDirectory: 'build',
+    serverBuildFile: 'index.js',
+    serverModuleFormat: 'esm',
+    ssr: true,
+  }
   let {
     appDirectory: userAppDirectory,
     basename: basename2,
@@ -351,76 +383,96 @@ async function resolveConfig({
     serverBuildFile,
     serverBundles,
     serverModuleFormat,
-    ssr
+    ssr,
   } = {
     ...defaults,
     // Default values should be completely overridden by user/preset config, not merged
-    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
-  };
+    ...mergeReactRouterConfig(...presets, reactRouterUserConfig),
+  }
   if (!ssr && serverBundles) {
-    serverBundles = void 0;
+    serverBundles = void 0
   }
-  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
+  let isValidPrerenderConfig =
+    prerender == null ||
+    typeof prerender === 'boolean' ||
+    Array.isArray(prerender) ||
+    typeof prerender === 'function'
   if (!isValidPrerenderConfig) {
     return err(
-      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
-    );
+      'The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths',
+    )
   }
-  let appDirectory = import_pathe.default.resolve(root, userAppDirectory || "app");
-  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory);
-  let rootRouteFile = findEntry(appDirectory, "root");
+  let appDirectory = import_pathe.default.resolve(
+    root,
+    userAppDirectory || 'app',
+  )
+  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory)
+  let rootRouteFile = findEntry(appDirectory, 'root')
   if (!rootRouteFile) {
     let rootRouteDisplayPath = import_pathe.default.relative(
       root,
-      import_pathe.default.join(appDirectory, "root.tsx")
-    );
+      import_pathe.default.join(appDirectory, 'root.tsx'),
+    )
     return err(
-      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
-    );
+      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`,
+    )
   }
   let routes = {
-    root: { path: "", id: "root", file: rootRouteFile }
-  };
-  let routeConfigFile = findEntry(appDirectory, "routes");
+    root: { path: '', id: 'root', file: rootRouteFile },
+  }
+  let routeConfigFile = findEntry(appDirectory, 'routes')
   try {
     if (!routeConfigFile) {
       let routeConfigDisplayPath = import_pathe.default.relative(
         root,
-        import_pathe.default.join(appDirectory, "routes.ts")
-      );
-      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
+        import_pathe.default.join(appDirectory, 'routes.ts'),
+      )
+      return err(`Route config file not found at "${routeConfigDisplayPath}".`)
     }
-    setAppDirectory(appDirectory);
-    let routeConfigExport = (await viteNodeContext.runner.executeFile(
-      import_pathe.default.join(appDirectory, routeConfigFile)
-    )).default;
-    let routeConfig = await routeConfigExport;
+    setAppDirectory(appDirectory)
+    let routeConfigExport = (
+      await viteNodeContext.runner.executeFile(
+        import_pathe.default.join(appDirectory, routeConfigFile),
+      )
+    ).default
+    let routeConfig = await routeConfigExport
     let result = validateRouteConfig({
       routeConfigFile,
-      routeConfig
-    });
+      routeConfig,
+    })
     if (!result.valid) {
-      return err(result.message);
+      return err(result.message)
     }
     routes = {
       ...routes,
-      ...configRoutesToRouteManifest(appDirectory, routeConfig)
-    };
+      ...configRoutesToRouteManifest(appDirectory, routeConfig),
+    }
   } catch (error) {
     return err(
       [
-        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
-        "",
-        error.loc?.file && error.loc?.column && error.frame ? [
-          import_pathe.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
-          error.frame.trim?.()
-        ] : error.stack
-      ].flat().join("\n")
-    );
+        import_picocolors.default.red(
+          `Route config in "${routeConfigFile}" is invalid.`,
+        ),
+        '',
+        error.loc?.file && error.loc?.column && error.frame
+          ? [
+              import_pathe.default.relative(appDirectory, error.loc.file) +
+                ':' +
+                error.loc.line +
+                ':' +
+                error.loc.column,
+              error.frame.trim?.(),
+            ]
+          : error.stack,
+      ]
+        .flat()
+        .join('\n'),
+    )
   }
   let future = {
-    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false
-  };
+    unstable_optimizeDeps:
+      reactRouterUserConfig.future?.unstable_optimizeDeps ?? false,
+  }
   let reactRouterConfig = deepFreeze({
     appDirectory,
     basename: basename2,
@@ -432,71 +484,77 @@ async function resolveConfig({
     serverBuildFile,
     serverBundles,
     serverModuleFormat,
-    ssr
-  });
+    ssr,
+  })
   for (let preset of reactRouterUserConfig.presets ?? []) {
-    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
+    await preset.reactRouterConfigResolved?.({ reactRouterConfig })
   }
-  return ok(reactRouterConfig);
+  return ok(reactRouterConfig)
 }
-async function createConfigLoader({
-  rootDirectory: root,
-  watch: watch2
-}) {
-  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
+async function createConfigLoader({ rootDirectory: root, watch: watch2 }) {
+  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd()
   let viteNodeContext = await createContext({
     root,
-    mode: watch2 ? "development" : "production",
+    mode: watch2 ? 'development' : 'production',
     server: !watch2 ? { watch: null } : {},
     ssr: {
-      external: ssrExternals
-    }
-  });
-  let reactRouterConfigFile = findEntry(root, "react-router.config", {
-    absolute: true
-  });
-  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
-  let appDirectory;
-  let initialConfigResult = await getConfig();
+      external: ssrExternals,
+    },
+  })
+  let reactRouterConfigFile = findEntry(root, 'react-router.config', {
+    absolute: true,
+  })
+  let getConfig = () =>
+    resolveConfig({ root, viteNodeContext, reactRouterConfigFile })
+  let appDirectory
+  let initialConfigResult = await getConfig()
   if (!initialConfigResult.ok) {
-    throw new Error(initialConfigResult.error);
+    throw new Error(initialConfigResult.error)
   }
-  appDirectory = initialConfigResult.value.appDirectory;
-  let lastConfig = initialConfigResult.value;
-  let fsWatcher;
-  let changeHandlers = [];
+  appDirectory = initialConfigResult.value.appDirectory
+  let lastConfig = initialConfigResult.value
+  let fsWatcher
+  let changeHandlers = []
   return {
     getConfig,
-    onChange: (handler) => {
+    onChange: handler => {
       if (!watch2) {
-        throw new Error(
-          "onChange is not supported when watch mode is disabled"
-        );
+        throw new Error('onChange is not supported when watch mode is disabled')
       }
-      changeHandlers.push(handler);
+      changeHandlers.push(handler)
       if (!fsWatcher) {
         fsWatcher = import_chokidar.default.watch(
           [
-            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
-            appDirectory
+            ...(reactRouterConfigFile ? [reactRouterConfigFile] : []),
+            appDirectory,
           ],
-          { ignoreInitial: true }
-        );
-        fsWatcher.on("all", async (...args) => {
-          let [event, rawFilepath] = args;
-          let filepath = import_pathe.default.normalize(rawFilepath);
-          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe.default.normalize(appDirectory));
+          { ignoreInitial: true },
+        )
+        fsWatcher.on('all', async (...args) => {
+          let [event, rawFilepath] = args
+          let filepath = import_pathe.default.normalize(rawFilepath)
+          let appFileAddedOrRemoved =
+            appDirectory &&
+            (event === 'add' || event === 'unlink') &&
+            filepath.startsWith(import_pathe.default.normalize(appDirectory))
           let configCodeUpdated = Boolean(
-            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
-          );
+            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath),
+          )
           if (configCodeUpdated || appFileAddedOrRemoved) {
-            viteNodeContext.devServer?.moduleGraph.invalidateAll();
-            viteNodeContext.runner?.moduleCache.clear();
+            viteNodeContext.devServer?.moduleGraph.invalidateAll()
+            viteNodeContext.runner?.moduleCache.clear()
           }
           if (appFileAddedOrRemoved || configCodeUpdated) {
-            let result = await getConfig();
-            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
-            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
+            let result = await getConfig()
+            let configChanged =
+              result.ok &&
+              !(0, import_isEqual.default)(lastConfig, result.value)
+            let routeConfigChanged =
+              result.ok &&
+              !(0, import_isEqual.default)(
+                lastConfig?.routes,
+                result.value.routes,
+              )
             for (let handler2 of changeHandlers) {
               handler2({
                 result,
@@ -504,145 +562,160 @@ async function createConfigLoader({
                 configChanged,
                 routeConfigChanged,
                 path: filepath,
-                event
-              });
+                event,
+              })
             }
             if (result.ok) {
-              lastConfig = result.value;
+              lastConfig = result.value
             }
           }
-        });
+        })
       }
       return () => {
         changeHandlers = changeHandlers.filter(
-          (changeHandler) => changeHandler !== handler
-        );
-      };
+          changeHandler => changeHandler !== handler,
+        )
+      }
     },
     close: async () => {
-      changeHandlers = [];
-      await viteNodeContext.devServer.close();
-      await fsWatcher?.close();
-    }
-  };
+      changeHandlers = []
+      await viteNodeContext.devServer.close()
+      await fsWatcher?.close()
+    },
+  }
 }
-async function resolveEntryFiles({
-  rootDirectory,
-  reactRouterConfig
-}) {
-  let { appDirectory } = reactRouterConfig;
+async function resolveEntryFiles({ rootDirectory, reactRouterConfig }) {
+  let { appDirectory } = reactRouterConfig
   let defaultsDirectory = import_pathe.default.resolve(
-    import_pathe.default.dirname(require.resolve("@react-router/dev/package.json")),
-    "dist",
-    "config",
-    "defaults"
-  );
-  let userEntryClientFile = findEntry(appDirectory, "entry.client");
-  let userEntryServerFile = findEntry(appDirectory, "entry.server");
-  let entryServerFile;
-  let entryClientFile = userEntryClientFile || "entry.client.tsx";
-  let pkgJson = await import_package_json.default.load(rootDirectory);
-  let deps = pkgJson.content.dependencies ?? {};
+    import_pathe.default.dirname(
+      require.resolve('@react-router/dev/package.json'),
+    ),
+    'dist',
+    'config',
+    'defaults',
+  )
+  let userEntryClientFile = findEntry(appDirectory, 'entry.client')
+  let userEntryServerFile = findEntry(appDirectory, 'entry.server')
+  let entryServerFile
+  let entryClientFile = userEntryClientFile || 'entry.client.tsx'
+  let pkgJson = await import_package_json.default.load(rootDirectory)
+  let deps = pkgJson.content.dependencies ?? {}
   if (userEntryServerFile) {
-    entryServerFile = userEntryServerFile;
+    entryServerFile = userEntryServerFile
   } else {
-    if (!deps["@react-router/node"]) {
+    if (!deps['@react-router/node']) {
       throw new Error(
-        `Could not determine server runtime. Please install @react-router/node, or provide a custom entry.server.tsx/jsx file in your app directory.`
-      );
+        `Could not determine server runtime. Please install @react-router/node, or provide a custom entry.server.tsx/jsx file in your app directory.`,
+      )
     }
-    if (!deps["isbot"]) {
+    if (!deps['isbot']) {
       console.log(
-        "adding `isbot@5` to your package.json, you should commit this change"
-      );
+        'adding `isbot@5` to your package.json, you should commit this change',
+      )
       pkgJson.update({
         dependencies: {
           ...pkgJson.content.dependencies,
-          isbot: "^5"
-        }
-      });
-      await pkgJson.save();
-      let packageManager = detectPackageManager() ?? "npm";
-      (0, import_node_child_process.execSync)(`${packageManager} install`, {
+          isbot: '^5',
+        },
+      })
+      await pkgJson.save()
+      let packageManager = detectPackageManager() ?? 'npm'
+      ;(0, import_node_child_process.execSync)(`${packageManager} install`, {
         cwd: rootDirectory,
-        stdio: "inherit"
-      });
+        stdio: 'inherit',
+      })
     }
-    entryServerFile = `entry.server.node.tsx`;
-  }
-  let entryClientFilePath = userEntryClientFile ? import_pathe.default.resolve(reactRouterConfig.appDirectory, userEntryClientFile) : import_pathe.default.resolve(defaultsDirectory, entryClientFile);
-  let entryServerFilePath = userEntryServerFile ? import_pathe.default.resolve(reactRouterConfig.appDirectory, userEntryServerFile) : import_pathe.default.resolve(defaultsDirectory, entryServerFile);
-  return { entryClientFilePath, entryServerFilePath };
-}
-var ssrExternals = isInReactRouterMonorepo() ? [
-  // This is only needed within this repo because these packages
-  // are linked to a directory outside of node_modules so Vite
-  // treats them as internal code by default.
-  "react-router",
-  "react-router-dom",
-  "@react-router/architect",
-  "@react-router/cloudflare",
-  "@react-router/dev",
-  "@react-router/express",
-  "@react-router/node",
-  "@react-router/serve"
-] : void 0;
+    entryServerFile = `entry.server.node.tsx`
+  }
+  let entryClientFilePath = userEntryClientFile
+    ? import_pathe.default.resolve(
+        reactRouterConfig.appDirectory,
+        userEntryClientFile,
+      )
+    : import_pathe.default.resolve(defaultsDirectory, entryClientFile)
+  let entryServerFilePath = userEntryServerFile
+    ? import_pathe.default.resolve(
+        reactRouterConfig.appDirectory,
+        userEntryServerFile,
+      )
+    : import_pathe.default.resolve(defaultsDirectory, entryServerFile)
+  return { entryClientFilePath, entryServerFilePath }
+}
+var ssrExternals = isInReactRouterMonorepo()
+  ? [
+      // This is only needed within this repo because these packages
+      // are linked to a directory outside of node_modules so Vite
+      // treats them as internal code by default.
+      'react-router',
+      'react-router-dom',
+      '@react-router/architect',
+      '@react-router/cloudflare',
+      '@react-router/dev',
+      '@react-router/express',
+      '@react-router/node',
+      '@react-router/serve',
+    ]
+  : void 0
 function isInReactRouterMonorepo() {
   let serverRuntimePath = import_pathe.default.dirname(
-    require.resolve("@react-router/node/package.json")
-  );
+    require.resolve('@react-router/node/package.json'),
+  )
   let serverRuntimeParentDir = import_pathe.default.basename(
-    import_pathe.default.resolve(serverRuntimePath, "..")
-  );
-  return serverRuntimeParentDir === "packages";
+    import_pathe.default.resolve(serverRuntimePath, '..'),
+  )
+  return serverRuntimeParentDir === 'packages'
 }
-var entryExts = [".js", ".jsx", ".ts", ".tsx"];
+var entryExts = ['.js', '.jsx', '.ts', '.tsx']
 function findEntry(dir, basename2, options) {
   for (let ext of entryExts) {
-    let file = import_pathe.default.resolve(dir, basename2 + ext);
+    let file = import_pathe.default.resolve(dir, basename2 + ext)
     if (import_node_fs.default.existsSync(file)) {
-      return options?.absolute ?? false ? file : import_pathe.default.relative(dir, file);
+      return options?.absolute ?? false
+        ? file
+        : import_pathe.default.relative(dir, file)
     }
   }
-  return void 0;
+  return void 0
 }
 
 // typegen/generate.ts
-var import_dedent = __toESM(require("dedent"));
-var Path3 = __toESM(require("pathe"));
-var Pathe2 = __toESM(require("pathe/utils"));
+var import_dedent = __toESM(require('dedent'))
+var Path3 = __toESM(require('pathe'))
+var Pathe2 = __toESM(require('pathe/utils'))
 
 // typegen/paths.ts
-var Path2 = __toESM(require("pathe"));
-var Pathe = __toESM(require("pathe/utils"));
+var Path2 = __toESM(require('pathe'))
+var Pathe = __toESM(require('pathe/utils'))
 function getTypesDir(ctx) {
-  return Path2.join(ctx.rootDirectory, ".react-router/types");
+  return Path2.join(ctx.rootDirectory, '.react-router/types')
 }
 function getTypesPath(ctx, route) {
   return Path2.join(
     getTypesDir(ctx),
     Path2.relative(ctx.rootDirectory, ctx.config.appDirectory),
     Path2.dirname(route.file),
-    "+types/" + Pathe.filename(route.file) + ".ts"
-  );
+    '+types/' + Pathe.filename(route.file) + '.ts',
+  )
 }
 
 // typegen/generate.ts
 function generate(ctx, route) {
-  const lineage = getRouteLineage(ctx.config.routes, route);
-  const urlpath = lineage.map((route2) => route2.path).join("/");
-  const typesPath = getTypesPath(ctx, route);
-  const parents = lineage.slice(0, -1);
-  const parentTypeImports = parents.map((parent, i) => {
-    const rel = Path3.relative(
-      Path3.dirname(typesPath),
-      getTypesPath(ctx, parent)
-    );
-    const indent = i === 0 ? "" : "  ".repeat(2);
-    let source = noExtension(rel);
-    if (!source.startsWith("../")) source = "./" + source;
-    return `${indent}import type { Info as Parent${i} } from "${source}"`;
-  }).join("\n");
+  const lineage = getRouteLineage(ctx.config.routes, route)
+  const urlpath = lineage.map(route2 => route2.path).join('/')
+  const typesPath = getTypesPath(ctx, route)
+  const parents = lineage.slice(0, -1)
+  const parentTypeImports = parents
+    .map((parent, i) => {
+      const rel = Path3.relative(
+        Path3.dirname(typesPath),
+        getTypesPath(ctx, parent),
+      )
+      const indent = i === 0 ? '' : '  '.repeat(2)
+      let source = noExtension(rel)
+      if (!source.startsWith('../')) source = './' + source
+      return `${indent}import type { Info as Parent${i} } from "${source}.ts"`
+    })
+    .join('\n')
   return import_dedent.default`
     // React Router generated types for route:
     // ${route.file}
@@ -651,10 +724,10 @@ function generate(ctx, route) {
 
     ${parentTypeImports}
 
-    type Module = typeof import("../${Pathe2.filename(route.file)}")
+    type Module = typeof import("../${Pathe2.filename(route.file)}.ts")
 
     export type Info = {
-      parents: [${parents.map((_, i) => `Parent${i}`).join(", ")}],
+      parents: [${parents.map((_, i) => `Parent${i}`).join(', ')}],
       id: "${route.id}"
       file: "${route.file}"
       path: "${route.path}"
@@ -684,301 +757,333 @@ function generate(ctx, route) {
       export type ComponentProps = T.CreateComponentProps<Info>
       export type ErrorBoundaryProps = T.CreateErrorBoundaryProps<Info>
     }
-  `;
+  `
 }
-var noExtension = (path5) => Path3.join(Path3.dirname(path5), Pathe2.filename(path5));
+var noExtension = path5 =>
+  Path3.join(Path3.dirname(path5), Pathe2.filename(path5))
 function getRouteLineage(routes, route) {
-  const result = [];
+  const result = []
   while (route) {
-    result.push(route);
-    if (!route.parentId) break;
-    route = routes[route.parentId];
+    result.push(route)
+    if (!route.parentId) break
+    route = routes[route.parentId]
   }
-  result.reverse();
-  return result;
+  result.reverse()
+  return result
 }
 function formatParamProperties(urlpath) {
-  const params = parseParams(urlpath);
+  const params = parseParams(urlpath)
   const properties = Object.entries(params).map(([name, values]) => {
     if (values.length === 1) {
-      const isOptional = values[0];
-      return isOptional ? `"${name}"?: string` : `"${name}": string`;
+      const isOptional = values[0]
+      return isOptional ? `"${name}"?: string` : `"${name}": string`
     }
-    const items = values.map(
-      (isOptional) => isOptional ? "string | undefined" : "string"
-    );
-    return `"${name}": [${items.join(", ")}]`;
-  });
-  return properties.join("; ");
+    const items = values.map(isOptional =>
+      isOptional ? 'string | undefined' : 'string',
+    )
+    return `"${name}": [${items.join(', ')}]`
+  })
+  return properties.join('; ')
 }
 function parseParams(urlpath) {
-  const result = {};
-  let segments = urlpath.split("/");
-  segments.forEach((segment) => {
-    const match = segment.match(/^:([\w-]+)(\?)?/);
-    if (!match) return;
-    const param = match[1];
-    const isOptional = match[2] !== void 0;
-    result[param] ??= [];
-    result[param].push(isOptional);
-    return;
-  });
-  const hasSplat = segments.at(-1) === "*";
-  if (hasSplat) result["*"] = [false];
-  return result;
+  const result = {}
+  let segments = urlpath.split('/')
+  segments.forEach(segment => {
+    const match = segment.match(/^:([\w-]+)(\?)?/)
+    if (!match) return
+    const param = match[1]
+    const isOptional = match[2] !== void 0
+    result[param] ??= []
+    result[param].push(isOptional)
+    return
+  })
+  const hasSplat = segments.at(-1) === '*'
+  if (hasSplat) result['*'] = [false]
+  return result
 }
 
 // typegen/index.ts
 async function watch(rootDirectory, { logger } = {}) {
-  const ctx = await createContext2({ rootDirectory, watch: true });
-  await writeAll(ctx);
-  logger?.info(import_picocolors2.default.green("generated types"), { timestamp: true, clear: true });
+  const ctx = await createContext2({ rootDirectory, watch: true })
+  await writeAll(ctx)
+  logger?.info(import_picocolors2.default.green('generated types'), {
+    timestamp: true,
+    clear: true,
+  })
   ctx.configLoader.onChange(async ({ result, routeConfigChanged }) => {
     if (!result.ok) {
-      logger?.error(import_picocolors2.default.red(result.error), { timestamp: true, clear: true });
-      return;
+      logger?.error(import_picocolors2.default.red(result.error), {
+        timestamp: true,
+        clear: true,
+      })
+      return
     }
-    ctx.config = result.value;
+    ctx.config = result.value
     if (routeConfigChanged) {
-      await writeAll(ctx);
-      logger?.info(import_picocolors2.default.green("regenerated types"), {
+      await writeAll(ctx)
+      logger?.info(import_picocolors2.default.green('regenerated types'), {
         timestamp: true,
-        clear: true
-      });
+        clear: true,
+      })
     }
-  });
+  })
   return {
-    close: async () => await ctx.configLoader.close()
-  };
+    close: async () => await ctx.configLoader.close(),
+  }
 }
-async function createContext2({
-  rootDirectory,
-  watch: watch2
-}) {
-  const configLoader = await createConfigLoader({ rootDirectory, watch: watch2 });
-  const configResult = await configLoader.getConfig();
+async function createContext2({ rootDirectory, watch: watch2 }) {
+  const configLoader = await createConfigLoader({
+    rootDirectory,
+    watch: watch2,
+  })
+  const configResult = await configLoader.getConfig()
   if (!configResult.ok) {
-    throw new Error(configResult.error);
+    throw new Error(configResult.error)
   }
-  const config = configResult.value;
+  const config = configResult.value
   return {
     configLoader,
     rootDirectory,
-    config
-  };
+    config,
+  }
 }
 async function writeAll(ctx) {
-  const typegenDir = getTypesDir(ctx);
-  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true });
-  Object.values(ctx.config.routes).forEach((route) => {
-    const typesPath = getTypesPath(ctx, route);
-    const content = generate(ctx, route);
-    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), { recursive: true });
-    import_node_fs2.default.writeFileSync(typesPath, content);
-  });
+  const typegenDir = getTypesDir(ctx)
+  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true })
+  Object.values(ctx.config.routes).forEach(route => {
+    const typesPath = getTypesPath(ctx, route)
+    const content = generate(ctx, route)
+    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), {
+      recursive: true,
+    })
+    import_node_fs2.default.writeFileSync(typesPath, content)
+  })
 }
 
 // vite/babel.ts
-var import_parser = require("@babel/parser");
-var t = __toESM(require("@babel/types"));
-var traverse = require("@babel/traverse").default;
-var generate2 = require("@babel/generator").default;
+var import_parser = require('@babel/parser')
+var t = __toESM(require('@babel/types'))
+var traverse = require('@babel/traverse').default
+var generate2 = require('@babel/generator').default
 
 // vite/node-adapter.ts
-var import_node_events = require("events");
-var import_node_stream = require("stream");
-var import_set_cookie_parser = require("set-cookie-parser");
-var import_node = require("@react-router/node");
+var import_node_events = require('events')
+var import_node_stream = require('stream')
+var import_set_cookie_parser = require('set-cookie-parser')
+var import_node = require('@react-router/node')
 function fromNodeHeaders(nodeHeaders) {
-  let headers = new Headers();
+  let headers = new Headers()
   for (let [key, values] of Object.entries(nodeHeaders)) {
     if (values) {
       if (Array.isArray(values)) {
         for (let value of values) {
-          headers.append(key, value);
+          headers.append(key, value)
         }
       } else {
-        headers.set(key, values);
+        headers.set(key, values)
       }
     }
   }
-  return headers;
+  return headers
 }
 function fromNodeRequest(nodeReq, nodeRes) {
-  let origin = nodeReq.headers.origin && "null" !== nodeReq.headers.origin ? nodeReq.headers.origin : `http://${nodeReq.headers.host}`;
-  invariant(
-    nodeReq.originalUrl,
-    "Expected `nodeReq.originalUrl` to be defined"
-  );
-  let url3 = new URL(nodeReq.originalUrl, origin);
-  let controller = new AbortController();
+  let origin =
+    nodeReq.headers.origin && 'null' !== nodeReq.headers.origin
+      ? nodeReq.headers.origin
+      : `http://${nodeReq.headers.host}`
+  invariant(nodeReq.originalUrl, 'Expected `nodeReq.originalUrl` to be defined')
+  let url3 = new URL(nodeReq.originalUrl, origin)
+  let controller = new AbortController()
   let init = {
     method: nodeReq.method,
     headers: fromNodeHeaders(nodeReq.headers),
-    signal: controller.signal
-  };
-  nodeRes.on("finish", () => controller = null);
-  nodeRes.on("close", () => controller?.abort());
-  if (nodeReq.method !== "GET" && nodeReq.method !== "HEAD") {
-    init.body = (0, import_node.createReadableStreamFromReadable)(nodeReq);
-    init.duplex = "half";
+    signal: controller.signal,
+  }
+  nodeRes.on('finish', () => (controller = null))
+  nodeRes.on('close', () => controller?.abort())
+  if (nodeReq.method !== 'GET' && nodeReq.method !== 'HEAD') {
+    init.body = (0, import_node.createReadableStreamFromReadable)(nodeReq)
+    init.duplex = 'half'
   }
-  return new Request(url3.href, init);
+  return new Request(url3.href, init)
 }
 async function toNodeRequest(res, nodeRes) {
-  nodeRes.statusCode = res.status;
-  nodeRes.statusMessage = res.statusText;
-  let cookiesStrings = [];
+  nodeRes.statusCode = res.status
+  nodeRes.statusMessage = res.statusText
+  let cookiesStrings = []
   for (let [name, value] of res.headers) {
-    if (name === "set-cookie") {
-      cookiesStrings.push(...(0, import_set_cookie_parser.splitCookiesString)(value));
-    } else nodeRes.setHeader(name, value);
+    if (name === 'set-cookie') {
+      cookiesStrings.push(
+        ...(0, import_set_cookie_parser.splitCookiesString)(value),
+      )
+    } else nodeRes.setHeader(name, value)
   }
   if (cookiesStrings.length) {
-    nodeRes.setHeader("set-cookie", cookiesStrings);
+    nodeRes.setHeader('set-cookie', cookiesStrings)
   }
   if (res.body) {
-    let responseBody = res.body;
-    let readable = import_node_stream.Readable.from(responseBody);
-    readable.pipe(nodeRes);
-    await (0, import_node_events.once)(readable, "end");
+    let responseBody = res.body
+    let readable = import_node_stream.Readable.from(responseBody)
+    readable.pipe(nodeRes)
+    await (0, import_node_events.once)(readable, 'end')
   } else {
-    nodeRes.end();
+    nodeRes.end()
   }
 }
 
 // vite/styles.ts
-var path3 = __toESM(require("path"));
-var import_react_router = require("react-router");
+var path3 = __toESM(require('path'))
+var import_react_router = require('react-router')
 
 // vite/resolve-file-url.ts
-var path2 = __toESM(require("path"));
+var path2 = __toESM(require('path'))
 var resolveFileUrl = ({ rootDirectory }, filePath) => {
-  let vite2 = importViteEsmSync();
-  let relativePath = path2.relative(rootDirectory, filePath);
-  let isWithinRoot = !relativePath.startsWith("..") && !path2.isAbsolute(relativePath);
+  let vite2 = importViteEsmSync()
+  let relativePath = path2.relative(rootDirectory, filePath)
+  let isWithinRoot =
+    !relativePath.startsWith('..') && !path2.isAbsolute(relativePath)
   if (!isWithinRoot) {
-    return path2.posix.join("/@fs", vite2.normalizePath(filePath));
+    return path2.posix.join('/@fs', vite2.normalizePath(filePath))
   }
-  return "/" + vite2.normalizePath(relativePath);
-};
+  return '/' + vite2.normalizePath(relativePath)
+}
 
 // vite/styles.ts
-var cssFileRegExp = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
-var cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`);
-var isCssFile = (file) => cssFileRegExp.test(file);
-var isCssModulesFile = (file) => cssModulesRegExp.test(file);
-var cssUrlParamsWithoutSideEffects = ["url", "inline", "raw", "inline-css"];
-var isCssUrlWithoutSideEffects = (url3) => {
-  let queryString = url3.split("?")[1];
+var cssFileRegExp =
+  /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/
+var cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`)
+var isCssFile = file => cssFileRegExp.test(file)
+var isCssModulesFile = file => cssModulesRegExp.test(file)
+var cssUrlParamsWithoutSideEffects = ['url', 'inline', 'raw', 'inline-css']
+var isCssUrlWithoutSideEffects = url3 => {
+  let queryString = url3.split('?')[1]
   if (!queryString) {
-    return false;
+    return false
   }
-  let params = new URLSearchParams(queryString);
+  let params = new URLSearchParams(queryString)
   for (let paramWithoutSideEffects of cssUrlParamsWithoutSideEffects) {
     if (
       // Parameter is blank and not explicitly set, i.e. "?url", not "?url="
-      params.get(paramWithoutSideEffects) === "" && !url3.includes(`?${paramWithoutSideEffects}=`) && !url3.includes(`&${paramWithoutSideEffects}=`)
+      params.get(paramWithoutSideEffects) === '' &&
+      !url3.includes(`?${paramWithoutSideEffects}=`) &&
+      !url3.includes(`&${paramWithoutSideEffects}=`)
     ) {
-      return true;
+      return true
     }
   }
-  return false;
-};
+  return false
+}
 var getStylesForFiles = async ({
   viteDevServer,
   rootDirectory,
   cssModulesManifest,
-  files
+  files,
 }) => {
-  let styles = {};
-  let deps = /* @__PURE__ */ new Set();
+  let styles = {}
+  let deps = /* @__PURE__ */ new Set()
   try {
     for (let file of files) {
-      let normalizedPath = path3.resolve(rootDirectory, file).replace(/\\/g, "/");
-      let node = await viteDevServer.moduleGraph.getModuleById(normalizedPath);
+      let normalizedPath = path3
+        .resolve(rootDirectory, file)
+        .replace(/\\/g, '/')
+      let node = await viteDevServer.moduleGraph.getModuleById(normalizedPath)
       if (!node) {
         try {
           await viteDevServer.transformRequest(
-            resolveFileUrl({ rootDirectory }, normalizedPath)
-          );
+            resolveFileUrl({ rootDirectory }, normalizedPath),
+          )
         } catch (err2) {
-          console.error(err2);
+          console.error(err2)
         }
-        node = await viteDevServer.moduleGraph.getModuleById(normalizedPath);
+        node = await viteDevServer.moduleGraph.getModuleById(normalizedPath)
       }
       if (!node) {
-        console.log(`Could not resolve module for file: ${file}`);
-        continue;
+        console.log(`Could not resolve module for file: ${file}`)
+        continue
       }
-      await findDeps(viteDevServer, node, deps);
+      await findDeps(viteDevServer, node, deps)
     }
   } catch (err2) {
-    console.error(err2);
+    console.error(err2)
   }
   for (let dep of deps) {
-    if (dep.file && isCssFile(dep.file) && !isCssUrlWithoutSideEffects(dep.url)) {
+    if (
+      dep.file &&
+      isCssFile(dep.file) &&
+      !isCssUrlWithoutSideEffects(dep.url)
+    ) {
       try {
-        let css = isCssModulesFile(dep.file) ? cssModulesManifest[dep.file] : (await viteDevServer.ssrLoadModule(dep.url)).default;
+        let css = isCssModulesFile(dep.file)
+          ? cssModulesManifest[dep.file]
+          : (await viteDevServer.ssrLoadModule(dep.url)).default
         if (css === void 0) {
-          throw new Error();
+          throw new Error()
         }
-        styles[dep.url] = css;
+        styles[dep.url] = css
       } catch {
-        console.warn(`Could not load ${dep.file}`);
+        console.warn(`Could not load ${dep.file}`)
       }
     }
   }
-  return Object.entries(styles).map(([fileName, css], i) => [
-    `
-/* ${fileName.replace(/\/\*/g, "/\\*").replace(/\*\//g, "*\\/")} */`,
-    css
-  ]).flat().join("\n") || void 0;
-};
+  return (
+    Object.entries(styles)
+      .map(([fileName, css], i) => [
+        `
+/* ${fileName.replace(/\/\*/g, '/\\*').replace(/\*\//g, '*\\/')} */`,
+        css,
+      ])
+      .flat()
+      .join('\n') || void 0
+  )
+}
 var findDeps = async (vite2, node, deps) => {
-  let branches = [];
+  let branches = []
   async function addFromNode(node2) {
     if (!deps.has(node2)) {
-      deps.add(node2);
-      await findDeps(vite2, node2, deps);
+      deps.add(node2)
+      await findDeps(vite2, node2, deps)
     }
   }
   async function addFromUrl(url3) {
-    let node2 = await vite2.moduleGraph.getModuleByUrl(url3);
+    let node2 = await vite2.moduleGraph.getModuleByUrl(url3)
     if (node2) {
-      await addFromNode(node2);
+      await addFromNode(node2)
     }
   }
   if (node.ssrTransformResult) {
     if (node.ssrTransformResult.deps) {
-      node.ssrTransformResult.deps.forEach(
-        (url3) => branches.push(addFromUrl(url3))
-      );
+      node.ssrTransformResult.deps.forEach(url3 =>
+        branches.push(addFromUrl(url3)),
+      )
     }
   } else {
-    node.importedModules.forEach((node2) => branches.push(addFromNode(node2)));
+    node.importedModules.forEach(node2 => branches.push(addFromNode(node2)))
   }
-  await Promise.all(branches);
-};
-var groupRoutesByParentId = (manifest) => {
-  let routes = {};
-  Object.values(manifest).forEach((route) => {
+  await Promise.all(branches)
+}
+var groupRoutesByParentId = manifest => {
+  let routes = {}
+  Object.values(manifest).forEach(route => {
     if (route) {
-      let parentId = route.parentId || "";
+      let parentId = route.parentId || ''
       if (!routes[parentId]) {
-        routes[parentId] = [];
+        routes[parentId] = []
       }
-      routes[parentId].push(route);
+      routes[parentId].push(route)
     }
-  });
-  return routes;
-};
-var createRoutes = (manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) => {
-  return (routesByParentId[parentId] || []).map((route) => ({
+  })
+  return routes
+}
+var createRoutes = (
+  manifest,
+  parentId = '',
+  routesByParentId = groupRoutesByParentId(manifest),
+) => {
+  return (routesByParentId[parentId] || []).map(route => ({
     ...route,
-    children: createRoutes(manifest, route.id, routesByParentId)
-  }));
-};
+    children: createRoutes(manifest, route.id, routesByParentId),
+  }))
+}
 var getStylesForUrl = async ({
   viteDevServer,
   rootDirectory,
@@ -986,16 +1091,18 @@ var getStylesForUrl = async ({
   entryClientFilePath,
   cssModulesManifest,
   build,
-  url: url3
+  url: url3,
 }) => {
-  if (url3 === void 0 || url3.includes("?_data=")) {
-    return void 0;
-  }
-  let routes = createRoutes(build.routes);
-  let appPath = path3.relative(process.cwd(), reactRouterConfig.appDirectory);
-  let documentRouteFiles = (0, import_react_router.matchRoutes)(routes, url3, build.basename)?.map(
-    (match) => path3.resolve(appPath, reactRouterConfig.routes[match.route.id].file)
-  ) ?? [];
+  if (url3 === void 0 || url3.includes('?_data=')) {
+    return void 0
+  }
+  let routes = createRoutes(build.routes)
+  let appPath = path3.relative(process.cwd(), reactRouterConfig.appDirectory)
+  let documentRouteFiles =
+    (0, import_react_router.matchRoutes)(routes, url3, build.basename)?.map(
+      match =>
+        path3.resolve(appPath, reactRouterConfig.routes[match.route.id].file),
+    ) ?? []
   let styles = await getStylesForFiles({
     viteDevServer,
     rootDirectory,
@@ -1004,140 +1111,178 @@ var getStylesForUrl = async ({
       // Always include the client entry file when crawling the module graph for CSS
       path3.relative(rootDirectory, entryClientFilePath),
       // Then include any styles from the matched routes
-      ...documentRouteFiles
-    ]
-  });
-  return styles;
-};
+      ...documentRouteFiles,
+    ],
+  })
+  return styles
+}
 
 // vite/vmod.ts
-var id = (name) => `virtual:react-router/${name}`;
-var resolve3 = (id2) => `\0${id2}`;
-var url = (id2) => `/@id/__x00__${id2}`;
+var id = name => `virtual:react-router/${name}`
+var resolve3 = id2 => `\0${id2}`
+var url = id2 => `/@id/__x00__${id2}`
 
 // vite/combine-urls.ts
 function combineURLs(baseURL, relativeURL) {
-  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
+  return relativeURL
+    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
+    : baseURL
 }
 
 // vite/remove-exports.ts
-var import_babel_dead_code_elimination = require("babel-dead-code-elimination");
+var import_babel_dead_code_elimination = require('babel-dead-code-elimination')
 var removeExports = (ast, exportsToRemove) => {
-  let previouslyReferencedIdentifiers = (0, import_babel_dead_code_elimination.findReferencedIdentifiers)(ast);
-  let exportsFiltered = false;
-  let markedForRemoval = /* @__PURE__ */ new Set();
+  let previouslyReferencedIdentifiers = (0,
+  import_babel_dead_code_elimination.findReferencedIdentifiers)(ast)
+  let exportsFiltered = false
+  let markedForRemoval = /* @__PURE__ */ new Set()
   traverse(ast, {
     ExportDeclaration(path5) {
-      if (path5.node.type === "ExportNamedDeclaration") {
+      if (path5.node.type === 'ExportNamedDeclaration') {
         if (path5.node.specifiers.length) {
-          path5.node.specifiers = path5.node.specifiers.filter((specifier) => {
-            if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier") {
+          path5.node.specifiers = path5.node.specifiers.filter(specifier => {
+            if (
+              specifier.type === 'ExportSpecifier' &&
+              specifier.exported.type === 'Identifier'
+            ) {
               if (exportsToRemove.includes(specifier.exported.name)) {
-                exportsFiltered = true;
-                return false;
+                exportsFiltered = true
+                return false
               }
             }
-            return true;
-          });
+            return true
+          })
           if (path5.node.specifiers.length === 0) {
-            markedForRemoval.add(path5);
+            markedForRemoval.add(path5)
           }
         }
-        if (path5.node.declaration?.type === "VariableDeclaration") {
-          let declaration = path5.node.declaration;
+        if (path5.node.declaration?.type === 'VariableDeclaration') {
+          let declaration = path5.node.declaration
           declaration.declarations = declaration.declarations.filter(
-            (declaration2) => {
-              if (declaration2.id.type === "Identifier" && exportsToRemove.includes(declaration2.id.name)) {
-                exportsFiltered = true;
-                return false;
+            declaration2 => {
+              if (
+                declaration2.id.type === 'Identifier' &&
+                exportsToRemove.includes(declaration2.id.name)
+              ) {
+                exportsFiltered = true
+                return false
               }
-              if (declaration2.id.type === "ArrayPattern" || declaration2.id.type === "ObjectPattern") {
-                validateDestructuredExports(declaration2.id, exportsToRemove);
+              if (
+                declaration2.id.type === 'ArrayPattern' ||
+                declaration2.id.type === 'ObjectPattern'
+              ) {
+                validateDestructuredExports(declaration2.id, exportsToRemove)
               }
-              return true;
-            }
-          );
+              return true
+            },
+          )
           if (declaration.declarations.length === 0) {
-            markedForRemoval.add(path5);
+            markedForRemoval.add(path5)
           }
         }
-        if (path5.node.declaration?.type === "FunctionDeclaration") {
-          let id2 = path5.node.declaration.id;
+        if (path5.node.declaration?.type === 'FunctionDeclaration') {
+          let id2 = path5.node.declaration.id
           if (id2 && exportsToRemove.includes(id2.name)) {
-            markedForRemoval.add(path5);
+            markedForRemoval.add(path5)
           }
         }
-        if (path5.node.declaration?.type === "ClassDeclaration") {
-          let id2 = path5.node.declaration.id;
+        if (path5.node.declaration?.type === 'ClassDeclaration') {
+          let id2 = path5.node.declaration.id
           if (id2 && exportsToRemove.includes(id2.name)) {
-            markedForRemoval.add(path5);
+            markedForRemoval.add(path5)
           }
         }
       }
-      if (path5.node.type === "ExportDefaultDeclaration" && exportsToRemove.includes("default")) {
-        markedForRemoval.add(path5);
+      if (
+        path5.node.type === 'ExportDefaultDeclaration' &&
+        exportsToRemove.includes('default')
+      ) {
+        markedForRemoval.add(path5)
       }
-    }
-  });
+    },
+  })
   if (markedForRemoval.size > 0 || exportsFiltered) {
     for (let path5 of markedForRemoval) {
-      path5.remove();
+      path5.remove()
     }
-    (0, import_babel_dead_code_elimination.deadCodeElimination)(ast, previouslyReferencedIdentifiers);
+    ;(0, import_babel_dead_code_elimination.deadCodeElimination)(
+      ast,
+      previouslyReferencedIdentifiers,
+    )
   }
-};
+}
 function validateDestructuredExports(id2, exportsToRemove) {
-  if (id2.type === "ArrayPattern") {
+  if (id2.type === 'ArrayPattern') {
     for (let element of id2.elements) {
       if (!element) {
-        continue;
+        continue
       }
-      if (element.type === "Identifier" && exportsToRemove.includes(element.name)) {
-        throw invalidDestructureError(element.name);
+      if (
+        element.type === 'Identifier' &&
+        exportsToRemove.includes(element.name)
+      ) {
+        throw invalidDestructureError(element.name)
       }
-      if (element.type === "RestElement" && element.argument.type === "Identifier" && exportsToRemove.includes(element.argument.name)) {
-        throw invalidDestructureError(element.argument.name);
+      if (
+        element.type === 'RestElement' &&
+        element.argument.type === 'Identifier' &&
+        exportsToRemove.includes(element.argument.name)
+      ) {
+        throw invalidDestructureError(element.argument.name)
       }
-      if (element.type === "ArrayPattern" || element.type === "ObjectPattern") {
-        validateDestructuredExports(element, exportsToRemove);
+      if (element.type === 'ArrayPattern' || element.type === 'ObjectPattern') {
+        validateDestructuredExports(element, exportsToRemove)
       }
     }
   }
-  if (id2.type === "ObjectPattern") {
+  if (id2.type === 'ObjectPattern') {
     for (let property of id2.properties) {
       if (!property) {
-        continue;
+        continue
       }
-      if (property.type === "ObjectProperty" && property.key.type === "Identifier") {
-        if (property.value.type === "Identifier" && exportsToRemove.includes(property.value.name)) {
-          throw invalidDestructureError(property.value.name);
+      if (
+        property.type === 'ObjectProperty' &&
+        property.key.type === 'Identifier'
+      ) {
+        if (
+          property.value.type === 'Identifier' &&
+          exportsToRemove.includes(property.value.name)
+        ) {
+          throw invalidDestructureError(property.value.name)
         }
-        if (property.value.type === "ArrayPattern" || property.value.type === "ObjectPattern") {
-          validateDestructuredExports(property.value, exportsToRemove);
+        if (
+          property.value.type === 'ArrayPattern' ||
+          property.value.type === 'ObjectPattern'
+        ) {
+          validateDestructuredExports(property.value, exportsToRemove)
         }
       }
-      if (property.type === "RestElement" && property.argument.type === "Identifier" && exportsToRemove.includes(property.argument.name)) {
-        throw invalidDestructureError(property.argument.name);
+      if (
+        property.type === 'RestElement' &&
+        property.argument.type === 'Identifier' &&
+        exportsToRemove.includes(property.argument.name)
+      ) {
+        throw invalidDestructureError(property.argument.name)
       }
     }
   }
 }
 function invalidDestructureError(name) {
-  return new Error(`Cannot remove destructured export "${name}"`);
+  return new Error(`Cannot remove destructured export "${name}"`)
 }
 
 // vite/with-props.ts
-var import_dedent2 = __toESM(require("dedent"));
-var vmodId = id("with-props");
-var NAMED_COMPONENT_EXPORTS = ["HydrateFallback", "ErrorBoundary"];
+var import_dedent2 = __toESM(require('dedent'))
+var vmodId = id('with-props')
+var NAMED_COMPONENT_EXPORTS = ['HydrateFallback', 'ErrorBoundary']
 var plugin = {
-  name: "react-router-with-props",
-  enforce: "pre",
+  name: 'react-router-with-props',
+  enforce: 'pre',
   resolveId(id2) {
-    if (id2 === vmodId) return resolve3(vmodId);
+    if (id2 === vmodId) return resolve3(vmodId)
   },
   async load(id2) {
-    if (id2 !== resolve3(vmodId)) return;
+    if (id2 !== resolve3(vmodId)) return
     return import_dedent2.default`
       import { createElement as h } from "react";
       import { useActionData, useLoaderData, useMatches, useParams, useRouteError } from "react-router";
@@ -1174,287 +1319,326 @@ var plugin = {
           return h(ErrorBoundary, props);
         };
       }
-    `;
-  }
-};
-var transform = (ast) => {
-  const hocs = [];
+    `
+  },
+}
+var transform = ast => {
+  const hocs = []
   function getHocUid(path5, hocName) {
-    const uid = path5.scope.generateUidIdentifier(hocName);
-    hocs.push([hocName, uid]);
-    return uid;
+    const uid = path5.scope.generateUidIdentifier(hocName)
+    hocs.push([hocName, uid])
+    return uid
   }
   traverse(ast, {
     ExportDeclaration(path5) {
       if (path5.isExportDefaultDeclaration()) {
-        const declaration = path5.get("declaration");
-        const expr = declaration.isExpression() ? declaration.node : declaration.isFunctionDeclaration() ? toFunctionExpression(declaration.node) : void 0;
+        const declaration = path5.get('declaration')
+        const expr = declaration.isExpression()
+          ? declaration.node
+          : declaration.isFunctionDeclaration()
+            ? toFunctionExpression(declaration.node)
+            : void 0
         if (expr) {
-          const uid = getHocUid(path5, "withComponentProps");
-          declaration.replaceWith(t.callExpression(uid, [expr]));
+          const uid = getHocUid(path5, 'withComponentProps')
+          declaration.replaceWith(t.callExpression(uid, [expr]))
         }
-        return;
+        return
       }
       if (path5.isExportNamedDeclaration()) {
-        const decl = path5.get("declaration");
+        const decl = path5.get('declaration')
         if (decl.isVariableDeclaration()) {
-          decl.get("declarations").forEach((varDeclarator) => {
-            const id2 = varDeclarator.get("id");
-            const init = varDeclarator.get("init");
-            const expr = init.node;
-            if (!expr) return;
-            if (!id2.isIdentifier()) return;
-            const { name } = id2.node;
-            if (!NAMED_COMPONENT_EXPORTS.includes(name)) return;
-            const uid = getHocUid(path5, `with${name}Props`);
-            init.replaceWith(t.callExpression(uid, [expr]));
-          });
-          return;
+          decl.get('declarations').forEach(varDeclarator => {
+            const id2 = varDeclarator.get('id')
+            const init = varDeclarator.get('init')
+            const expr = init.node
+            if (!expr) return
+            if (!id2.isIdentifier()) return
+            const { name } = id2.node
+            if (!NAMED_COMPONENT_EXPORTS.includes(name)) return
+            const uid = getHocUid(path5, `with${name}Props`)
+            init.replaceWith(t.callExpression(uid, [expr]))
+          })
+          return
         }
         if (decl.isFunctionDeclaration()) {
-          const { id: id2 } = decl.node;
-          if (!id2) return;
-          const { name } = id2;
-          if (!NAMED_COMPONENT_EXPORTS.includes(name)) return;
-          const uid = getHocUid(path5, `with${name}Props`);
+          const { id: id2 } = decl.node
+          if (!id2) return
+          const { name } = id2
+          if (!NAMED_COMPONENT_EXPORTS.includes(name)) return
+          const uid = getHocUid(path5, `with${name}Props`)
           decl.replaceWith(
-            t.variableDeclaration("const", [
+            t.variableDeclaration('const', [
               t.variableDeclarator(
                 t.identifier(name),
-                t.callExpression(uid, [toFunctionExpression(decl.node)])
-              )
-            ])
-          );
+                t.callExpression(uid, [toFunctionExpression(decl.node)]),
+              ),
+            ]),
+          )
         }
       }
-    }
-  });
+    },
+  })
   if (hocs.length > 0) {
     ast.program.body.unshift(
       t.importDeclaration(
-        hocs.map(
-          ([name, identifier]) => t.importSpecifier(identifier, t.identifier(name))
+        hocs.map(([name, identifier]) =>
+          t.importSpecifier(identifier, t.identifier(name)),
         ),
-        t.stringLiteral(vmodId)
-      )
-    );
+        t.stringLiteral(vmodId),
+      ),
+    )
   }
-};
+}
 function toFunctionExpression(decl) {
   return t.functionExpression(
     decl.id,
     decl.params,
     decl.body,
     decl.generator,
-    decl.async
-  );
+    decl.async,
+  )
 }
 
 // vite/plugin.ts
-var SERVER_ONLY_ROUTE_EXPORTS = ["loader", "action", "headers"];
+var SERVER_ONLY_ROUTE_EXPORTS = ['loader', 'action', 'headers']
 var CLIENT_ROUTE_EXPORTS = [
-  "clientAction",
-  "clientLoader",
-  "default",
-  "ErrorBoundary",
-  "handle",
-  "HydrateFallback",
-  "Layout",
-  "links",
-  "meta",
-  "shouldRevalidate"
-];
-var ROUTE_ENTRY_QUERY_STRING = "?route-entry=1";
-var isRouteEntry = (id2) => {
-  return id2.endsWith(ROUTE_ENTRY_QUERY_STRING);
-};
-var serverBuildId = id("server-build");
-var serverManifestId = id("server-manifest");
-var browserManifestId = id("browser-manifest");
-var hmrRuntimeId = id("hmr-runtime");
-var injectHmrRuntimeId = id("inject-hmr-runtime");
+  'clientAction',
+  'clientLoader',
+  'default',
+  'ErrorBoundary',
+  'handle',
+  'HydrateFallback',
+  'Layout',
+  'links',
+  'meta',
+  'shouldRevalidate',
+]
+var ROUTE_ENTRY_QUERY_STRING = '?route-entry=1'
+var isRouteEntry = id2 => {
+  return id2.endsWith(ROUTE_ENTRY_QUERY_STRING)
+}
+var serverBuildId = id('server-build')
+var serverManifestId = id('server-manifest')
+var browserManifestId = id('browser-manifest')
+var hmrRuntimeId = id('hmr-runtime')
+var injectHmrRuntimeId = id('inject-hmr-runtime')
 var resolveRelativeRouteFilePath = (route, reactRouterConfig) => {
-  let vite2 = importViteEsmSync();
-  let file = route.file;
-  let fullPath = path4.resolve(reactRouterConfig.appDirectory, file);
-  return vite2.normalizePath(fullPath);
-};
-var vmods = [serverBuildId, serverManifestId, browserManifestId];
-var invalidateVirtualModules = (viteDevServer) => {
-  vmods.forEach((vmod) => {
-    let mod = viteDevServer.moduleGraph.getModuleById(
-      resolve3(vmod)
-    );
+  let vite2 = importViteEsmSync()
+  let file = route.file
+  let fullPath = path4.resolve(reactRouterConfig.appDirectory, file)
+  return vite2.normalizePath(fullPath)
+}
+var vmods = [serverBuildId, serverManifestId, browserManifestId]
+var invalidateVirtualModules = viteDevServer => {
+  vmods.forEach(vmod => {
+    let mod = viteDevServer.moduleGraph.getModuleById(resolve3(vmod))
     if (mod) {
-      viteDevServer.moduleGraph.invalidateModule(mod);
+      viteDevServer.moduleGraph.invalidateModule(mod)
     }
-  });
-};
+  })
+}
 var getHash = (source, maxLength) => {
-  let hash = (0, import_node_crypto.createHash)("sha256").update(source).digest("hex");
-  return typeof maxLength === "number" ? hash.slice(0, maxLength) : hash;
-};
+  let hash = (0, import_node_crypto.createHash)('sha256')
+    .update(source)
+    .digest('hex')
+  return typeof maxLength === 'number' ? hash.slice(0, maxLength) : hash
+}
 var resolveChunk = (ctx, viteManifest, absoluteFilePath) => {
-  let vite2 = importViteEsmSync();
+  let vite2 = importViteEsmSync()
   let rootRelativeFilePath = vite2.normalizePath(
-    path4.relative(ctx.rootDirectory, absoluteFilePath)
-  );
-  let entryChunk = viteManifest[rootRelativeFilePath + ROUTE_ENTRY_QUERY_STRING] ?? viteManifest[rootRelativeFilePath];
+    path4.relative(ctx.rootDirectory, absoluteFilePath),
+  )
+  let entryChunk =
+    viteManifest[rootRelativeFilePath + ROUTE_ENTRY_QUERY_STRING] ??
+    viteManifest[rootRelativeFilePath]
   if (!entryChunk) {
-    let knownManifestKeys = Object.keys(viteManifest).map((key) => '"' + key + '"').join(", ");
+    let knownManifestKeys = Object.keys(viteManifest)
+      .map(key => '"' + key + '"')
+      .join(', ')
     throw new Error(
-      `No manifest entry found for "${rootRelativeFilePath}". Known manifest keys: ${knownManifestKeys}`
-    );
+      `No manifest entry found for "${rootRelativeFilePath}". Known manifest keys: ${knownManifestKeys}`,
+    )
   }
-  return entryChunk;
-};
-var getReactRouterManifestBuildAssets = (ctx, viteManifest, entryFilePath, prependedAssetFilePaths = []) => {
-  let entryChunk = resolveChunk(ctx, viteManifest, entryFilePath);
-  let prependedAssetChunks = prependedAssetFilePaths.map(
-    (filePath) => resolveChunk(ctx, viteManifest, filePath)
-  );
+  return entryChunk
+}
+var getReactRouterManifestBuildAssets = (
+  ctx,
+  viteManifest,
+  entryFilePath,
+  prependedAssetFilePaths = [],
+) => {
+  let entryChunk = resolveChunk(ctx, viteManifest, entryFilePath)
+  let prependedAssetChunks = prependedAssetFilePaths.map(filePath =>
+    resolveChunk(ctx, viteManifest, filePath),
+  )
   let chunks = resolveDependantChunks(viteManifest, [
     ...prependedAssetChunks,
-    entryChunk
-  ]);
+    entryChunk,
+  ])
   return {
     module: `${ctx.publicPath}${entryChunk.file}`,
-    imports: dedupe(chunks.flatMap((e) => e.imports ?? [])).map((imported) => {
-      return `${ctx.publicPath}${viteManifest[imported].file}`;
-    }) ?? [],
-    css: dedupe(chunks.flatMap((e) => e.css ?? [])).map((href) => {
-      return `${ctx.publicPath}${href}`;
-    }) ?? []
-  };
-};
+    imports:
+      dedupe(chunks.flatMap(e => e.imports ?? [])).map(imported => {
+        return `${ctx.publicPath}${viteManifest[imported].file}`
+      }) ?? [],
+    css:
+      dedupe(chunks.flatMap(e => e.css ?? [])).map(href => {
+        return `${ctx.publicPath}${href}`
+      }) ?? [],
+  }
+}
 function resolveDependantChunks(viteManifest, entryChunks) {
-  let chunks = /* @__PURE__ */ new Set();
+  let chunks = /* @__PURE__ */ new Set()
   function walk(chunk) {
     if (chunks.has(chunk)) {
-      return;
+      return
     }
-    chunks.add(chunk);
+    chunks.add(chunk)
     if (chunk.imports) {
       for (let importKey of chunk.imports) {
-        walk(viteManifest[importKey]);
+        walk(viteManifest[importKey])
       }
     }
   }
   for (let entryChunk of entryChunks) {
-    walk(entryChunk);
+    walk(entryChunk)
   }
-  return Array.from(chunks);
+  return Array.from(chunks)
 }
 function dedupe(array2) {
-  return [...new Set(array2)];
+  return [...new Set(array2)]
 }
 var writeFileSafe = async (file, contents) => {
-  await fse.ensureDir(path4.dirname(file));
-  await fse.writeFile(file, contents);
-};
+  await fse.ensureDir(path4.dirname(file))
+  await fse.writeFile(file, contents)
+}
 var getRouteManifestModuleExports = async (viteChildCompiler, ctx) => {
   let entries = await Promise.all(
     Object.entries(ctx.reactRouterConfig.routes).map(async ([key, route]) => {
       let sourceExports = await getRouteModuleExports(
         viteChildCompiler,
         ctx,
-        route.file
-      );
-      return [key, sourceExports];
-    })
-  );
-  return Object.fromEntries(entries);
-};
-var getRouteModuleExports = async (viteChildCompiler, ctx, routeFile, readRouteFile) => {
+        route.file,
+      )
+      return [key, sourceExports]
+    }),
+  )
+  return Object.fromEntries(entries)
+}
+var getRouteModuleExports = async (
+  viteChildCompiler,
+  ctx,
+  routeFile,
+  readRouteFile,
+) => {
   if (!viteChildCompiler) {
-    throw new Error("Vite child compiler not found");
+    throw new Error('Vite child compiler not found')
   }
-  let ssr = true;
-  let { pluginContainer, moduleGraph } = viteChildCompiler;
-  let routePath = path4.resolve(ctx.reactRouterConfig.appDirectory, routeFile);
-  let url3 = resolveFileUrl(ctx, routePath);
+  let ssr = true
+  let { pluginContainer, moduleGraph } = viteChildCompiler
+  let routePath = path4.resolve(ctx.reactRouterConfig.appDirectory, routeFile)
+  let url3 = resolveFileUrl(ctx, routePath)
   let resolveId = async () => {
-    let result = await pluginContainer.resolveId(url3, void 0, { ssr });
-    if (!result) throw new Error(`Could not resolve module ID for ${url3}`);
-    return result.id;
-  };
+    let result = await pluginContainer.resolveId(url3, void 0, { ssr })
+    if (!result) throw new Error(`Could not resolve module ID for ${url3}`)
+    return result.id
+  }
   let [id2, code] = await Promise.all([
     resolveId(),
-    readRouteFile?.() ?? fse.readFile(routePath, "utf-8"),
+    readRouteFile?.() ?? fse.readFile(routePath, 'utf-8'),
     // pluginContainer.transform(...) fails if we don't do this first:
-    moduleGraph.ensureEntryFromUrl(url3, ssr)
-  ]);
-  let transformed = await pluginContainer.transform(code, id2, { ssr });
-  let [, exports2] = (0, import_es_module_lexer.parse)(transformed.code);
-  let exportNames = exports2.map((e) => e.n);
-  return exportNames;
-};
-var getServerBundleBuildConfig = (viteUserConfig) => {
-  if (!("__reactRouterServerBundleBuildConfig" in viteUserConfig) || !viteUserConfig.__reactRouterServerBundleBuildConfig) {
-    return null;
-  }
-  return viteUserConfig.__reactRouterServerBundleBuildConfig;
-};
-var getServerBuildDirectory = (ctx) => path4.join(
-  ctx.reactRouterConfig.buildDirectory,
-  "server",
-  ...ctx.serverBundleBuildConfig ? [ctx.serverBundleBuildConfig.serverBundleId] : []
-);
-var getClientBuildDirectory = (reactRouterConfig) => path4.join(reactRouterConfig.buildDirectory, "client");
+    moduleGraph.ensureEntryFromUrl(url3, ssr),
+  ])
+  let transformed = await pluginContainer.transform(code, id2, { ssr })
+  let [, exports2] = (0, import_es_module_lexer.parse)(transformed.code)
+  let exportNames = exports2.map(e => e.n)
+  return exportNames
+}
+var getServerBundleBuildConfig = viteUserConfig => {
+  if (
+    !('__reactRouterServerBundleBuildConfig' in viteUserConfig) ||
+    !viteUserConfig.__reactRouterServerBundleBuildConfig
+  ) {
+    return null
+  }
+  return viteUserConfig.__reactRouterServerBundleBuildConfig
+}
+var getServerBuildDirectory = ctx =>
+  path4.join(
+    ctx.reactRouterConfig.buildDirectory,
+    'server',
+    ...(ctx.serverBundleBuildConfig
+      ? [ctx.serverBundleBuildConfig.serverBundleId]
+      : []),
+  )
+var getClientBuildDirectory = reactRouterConfig =>
+  path4.join(reactRouterConfig.buildDirectory, 'client')
 var defaultEntriesDir = path4.resolve(
-  path4.dirname(require.resolve("@react-router/dev/package.json")),
-  "dist",
-  "config",
-  "defaults"
-);
-var defaultEntries = fse.readdirSync(defaultEntriesDir).map((filename3) => path4.join(defaultEntriesDir, filename3));
-invariant(defaultEntries.length > 0, "No default entries found");
-var reactRouterDevLoadContext = () => ({});
+  path4.dirname(require.resolve('@react-router/dev/package.json')),
+  'dist',
+  'config',
+  'defaults',
+)
+var defaultEntries = fse
+  .readdirSync(defaultEntriesDir)
+  .map(filename3 => path4.join(defaultEntriesDir, filename3))
+invariant(defaultEntries.length > 0, 'No default entries found')
+var reactRouterDevLoadContext = () => ({})
 var reactRouterVitePlugin = () => {
-  let rootDirectory;
-  let viteCommand;
-  let viteUserConfig;
-  let viteConfigEnv;
-  let viteConfig;
-  let cssModulesManifest = {};
-  let viteChildCompiler = null;
-  let reactRouterConfigLoader;
-  let typegenWatcherPromise;
-  let logger;
-  let firstLoad = true;
-  let ctx;
+  let rootDirectory
+  let viteCommand
+  let viteUserConfig
+  let viteConfigEnv
+  let viteConfig
+  let cssModulesManifest = {}
+  let viteChildCompiler = null
+  let reactRouterConfigLoader
+  let typegenWatcherPromise
+  let logger
+  let firstLoad = true
+  let ctx
   let updatePluginContext = async () => {
-    let reactRouterConfig;
-    let reactRouterConfigResult = await reactRouterConfigLoader.getConfig();
+    let reactRouterConfig
+    let reactRouterConfigResult = await reactRouterConfigLoader.getConfig()
     if (reactRouterConfigResult.ok) {
-      reactRouterConfig = reactRouterConfigResult.value;
+      reactRouterConfig = reactRouterConfigResult.value
     } else {
-      logger.error(reactRouterConfigResult.error);
+      logger.error(reactRouterConfigResult.error)
       if (firstLoad) {
-        process.exit(1);
+        process.exit(1)
       }
-      return;
+      return
     }
     let { entryClientFilePath, entryServerFilePath } = await resolveEntryFiles({
       rootDirectory,
-      reactRouterConfig
-    });
-    let publicPath = viteUserConfig.base ?? "/";
-    if (reactRouterConfig.basename !== "/" && viteCommand === "serve" && !viteUserConfig.server?.middlewareMode && !reactRouterConfig.basename.startsWith(publicPath)) {
+      reactRouterConfig,
+    })
+    let publicPath = viteUserConfig.base ?? '/'
+    if (
+      reactRouterConfig.basename !== '/' &&
+      viteCommand === 'serve' &&
+      !viteUserConfig.server?.middlewareMode &&
+      !reactRouterConfig.basename.startsWith(publicPath)
+    ) {
       logger.error(
         import_picocolors3.default.red(
-          "When using the React Router `basename` and the Vite `base` config, the `basename` config must begin with `base` for the default Vite dev server."
-        )
-      );
-      process.exit(1);
+          'When using the React Router `basename` and the Vite `base` config, the `basename` config must begin with `base` for the default Vite dev server.',
+        ),
+      )
+      process.exit(1)
     }
-    let viteManifestEnabled = viteUserConfig.build?.manifest === true;
-    let ssrBuildCtx = viteConfigEnv.isSsrBuild && viteCommand === "build" ? {
-      isSsrBuild: true,
-      getReactRouterServerManifest: async () => (await generateReactRouterManifestsForBuild()).reactRouterServerManifest,
-      serverBundleBuildConfig: getServerBundleBuildConfig(viteUserConfig)
-    } : { isSsrBuild: false };
-    firstLoad = false;
+    let viteManifestEnabled = viteUserConfig.build?.manifest === true
+    let ssrBuildCtx =
+      viteConfigEnv.isSsrBuild && viteCommand === 'build'
+        ? {
+            isSsrBuild: true,
+            getReactRouterServerManifest: async () =>
+              (await generateReactRouterManifestsForBuild())
+                .reactRouterServerManifest,
+            serverBundleBuildConfig: getServerBundleBuildConfig(viteUserConfig),
+          }
+        : { isSsrBuild: false }
+    firstLoad = false
     ctx = {
       reactRouterConfig,
       rootDirectory,
@@ -1462,117 +1646,121 @@ var reactRouterVitePlugin = () => {
       entryServerFilePath,
       publicPath,
       viteManifestEnabled,
-      ...ssrBuildCtx
-    };
-  };
-  let pluginIndex = (pluginName) => {
-    invariant(viteConfig);
-    return viteConfig.plugins.findIndex((plugin2) => plugin2.name === pluginName);
-  };
+      ...ssrBuildCtx,
+    }
+  }
+  let pluginIndex = pluginName => {
+    invariant(viteConfig)
+    return viteConfig.plugins.findIndex(plugin2 => plugin2.name === pluginName)
+  }
   let getServerEntry = async () => {
-    invariant(viteConfig, "viteconfig required to generate the server entry");
-    let routes = ctx.serverBundleBuildConfig ? (
-      // For server bundle builds, the server build should only import the
-      // routes for this bundle rather than importing all routes
-      ctx.serverBundleBuildConfig.routes
-    ) : (
-      // Otherwise, all routes are imported as usual
-      ctx.reactRouterConfig.routes
-    );
+    invariant(viteConfig, 'viteconfig required to generate the server entry')
+    let routes = ctx.serverBundleBuildConfig
+      ? // For server bundle builds, the server build should only import the
+        // routes for this bundle rather than importing all routes
+        ctx.serverBundleBuildConfig.routes
+      : // Otherwise, all routes are imported as usual
+        ctx.reactRouterConfig.routes
     return `
     import * as entryServer from ${JSON.stringify(
-      resolveFileUrl(ctx, ctx.entryServerFilePath)
+      resolveFileUrl(ctx, ctx.entryServerFilePath),
     )};
-    ${Object.keys(routes).map((key, index) => {
-      let route = routes[key];
-      return `import * as route${index} from ${JSON.stringify(
-        resolveFileUrl(
-          ctx,
-          resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
-        ) + ROUTE_ENTRY_QUERY_STRING
-      )};`;
-    }).join("\n")}
+    ${Object.keys(routes)
+      .map((key, index) => {
+        let route = routes[key]
+        return `import * as route${index} from ${JSON.stringify(
+          resolveFileUrl(
+            ctx,
+            resolveRelativeRouteFilePath(route, ctx.reactRouterConfig),
+          ) + ROUTE_ENTRY_QUERY_STRING,
+        )};`
+      })
+      .join('\n')}
       export { default as assets } from ${JSON.stringify(serverManifestId)};
       export const assetsBuildDirectory = ${JSON.stringify(
-      path4.relative(
-        ctx.rootDirectory,
-        getClientBuildDirectory(ctx.reactRouterConfig)
-      )
-    )};
+        path4.relative(
+          ctx.rootDirectory,
+          getClientBuildDirectory(ctx.reactRouterConfig),
+        ),
+      )};
       export const basename = ${JSON.stringify(ctx.reactRouterConfig.basename)};
       export const future = ${JSON.stringify(ctx.reactRouterConfig.future)};
       export const isSpaMode = ${!ctx.reactRouterConfig.ssr && ctx.reactRouterConfig.prerender == null};
       export const publicPath = ${JSON.stringify(ctx.publicPath)};
       export const entry = { module: entryServer };
       export const routes = {
-        ${Object.keys(routes).map((key, index) => {
-      let route = routes[key];
-      return `${JSON.stringify(key)}: {
+        ${Object.keys(routes)
+          .map((key, index) => {
+            let route = routes[key]
+            return `${JSON.stringify(key)}: {
           id: ${JSON.stringify(route.id)},
           parentId: ${JSON.stringify(route.parentId)},
           path: ${JSON.stringify(route.path)},
           index: ${JSON.stringify(route.index)},
           caseSensitive: ${JSON.stringify(route.caseSensitive)},
           module: route${index}
-        }`;
-    }).join(",\n  ")}
-      };`;
-  };
-  let loadViteManifest = async (directory) => {
+        }`
+          })
+          .join(',\n  ')}
+      };`
+  }
+  let loadViteManifest = async directory => {
     let manifestContents = await fse.readFile(
-      path4.resolve(directory, ".vite", "manifest.json"),
-      "utf-8"
-    );
-    return JSON.parse(manifestContents);
-  };
-  let hasDependency = (name) => {
+      path4.resolve(directory, '.vite', 'manifest.json'),
+      'utf-8',
+    )
+    return JSON.parse(manifestContents)
+  }
+  let hasDependency = name => {
     try {
-      return Boolean(require.resolve(name, { paths: [ctx.rootDirectory] }));
+      return Boolean(require.resolve(name, { paths: [ctx.rootDirectory] }))
     } catch (err2) {
-      return false;
+      return false
     }
-  };
-  let getViteManifestAssetPaths = (viteManifest) => {
-    let cssUrlPaths = Object.values(viteManifest).filter((chunk) => chunk.file.endsWith(".css")).map((chunk) => chunk.file);
+  }
+  let getViteManifestAssetPaths = viteManifest => {
+    let cssUrlPaths = Object.values(viteManifest)
+      .filter(chunk => chunk.file.endsWith('.css'))
+      .map(chunk => chunk.file)
     let chunkAssetPaths = Object.values(viteManifest).flatMap(
-      (chunk) => chunk.assets ?? []
-    );
-    return /* @__PURE__ */ new Set([...cssUrlPaths, ...chunkAssetPaths]);
-  };
+      chunk => chunk.assets ?? [],
+    )
+    return /* @__PURE__ */ new Set([...cssUrlPaths, ...chunkAssetPaths])
+  }
   let generateReactRouterManifestsForBuild = async () => {
-    invariant(viteConfig);
+    invariant(viteConfig)
     let viteManifest = await loadViteManifest(
-      getClientBuildDirectory(ctx.reactRouterConfig)
-    );
+      getClientBuildDirectory(ctx.reactRouterConfig),
+    )
     let entry = getReactRouterManifestBuildAssets(
       ctx,
       viteManifest,
-      ctx.entryClientFilePath
-    );
-    let browserRoutes = {};
-    let serverRoutes = {};
+      ctx.entryClientFilePath,
+    )
+    let browserRoutes = {}
+    let serverRoutes = {}
     let routeManifestExports = await getRouteManifestModuleExports(
       viteChildCompiler,
-      ctx
-    );
+      ctx,
+    )
     for (let [key, route] of Object.entries(ctx.reactRouterConfig.routes)) {
       let routeFilePath = path4.join(
         ctx.reactRouterConfig.appDirectory,
-        route.file
-      );
-      let sourceExports = routeManifestExports[key];
-      let isRootRoute = route.parentId === void 0;
+        route.file,
+      )
+      let sourceExports = routeManifestExports[key]
+      let isRootRoute = route.parentId === void 0
       let routeManifestEntry = {
         id: route.id,
         parentId: route.parentId,
         path: route.path,
         index: route.index,
         caseSensitive: route.caseSensitive,
-        hasAction: sourceExports.includes("action"),
-        hasLoader: sourceExports.includes("loader"),
-        hasClientAction: sourceExports.includes("clientAction"),
-        hasClientLoader: sourceExports.includes("clientLoader"),
-        hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
+        hasAction: sourceExports.includes('action'),
+        hasLoader: sourceExports.includes('loader'),
+        hasClientAction: sourceExports.includes('clientAction'),
+        hasClientLoader: sourceExports.includes('clientLoader'),
+        hasErrorBoundary: sourceExports.includes('ErrorBoundary'),
         ...getReactRouterManifestBuildAssets(
           ctx,
           viteManifest,
@@ -1580,50 +1768,50 @@ var reactRouterVitePlugin = () => {
           // If this is the root route, we also need to include assets from the
           // client entry file as this is a common way for consumers to import
           // global reset styles, etc.
-          isRootRoute ? [ctx.entryClientFilePath] : []
-        )
-      };
-      browserRoutes[key] = routeManifestEntry;
-      let serverBundleRoutes = ctx.serverBundleBuildConfig?.routes;
+          isRootRoute ? [ctx.entryClientFilePath] : [],
+        ),
+      }
+      browserRoutes[key] = routeManifestEntry
+      let serverBundleRoutes = ctx.serverBundleBuildConfig?.routes
       if (!serverBundleRoutes || serverBundleRoutes[key]) {
-        serverRoutes[key] = routeManifestEntry;
+        serverRoutes[key] = routeManifestEntry
       }
     }
-    let fingerprintedValues = { entry, routes: browserRoutes };
-    let version = getHash(JSON.stringify(fingerprintedValues), 8);
+    let fingerprintedValues = { entry, routes: browserRoutes }
+    let version = getHash(JSON.stringify(fingerprintedValues), 8)
     let manifestPath = path4.posix.join(
       viteConfig.build.assetsDir,
-      `manifest-${version}.js`
-    );
-    let url3 = `${ctx.publicPath}${manifestPath}`;
-    let nonFingerprintedValues = { url: url3, version };
+      `manifest-${version}.js`,
+    )
+    let url3 = `${ctx.publicPath}${manifestPath}`
+    let nonFingerprintedValues = { url: url3, version }
     let reactRouterBrowserManifest = {
       ...fingerprintedValues,
-      ...nonFingerprintedValues
-    };
+      ...nonFingerprintedValues,
+    }
     await writeFileSafe(
       path4.join(getClientBuildDirectory(ctx.reactRouterConfig), manifestPath),
       `window.__reactRouterManifest=${JSON.stringify(
-        reactRouterBrowserManifest
-      )};`
-    );
+        reactRouterBrowserManifest,
+      )};`,
+    )
     let reactRouterServerManifest = {
       ...reactRouterBrowserManifest,
-      routes: serverRoutes
-    };
+      routes: serverRoutes,
+    }
     return {
       reactRouterBrowserManifest,
-      reactRouterServerManifest
-    };
-  };
+      reactRouterServerManifest,
+    }
+  }
   let getReactRouterManifestForDev = async () => {
-    let routes = {};
+    let routes = {}
     let routeManifestExports = await getRouteManifestModuleExports(
       viteChildCompiler,
-      ctx
-    );
+      ctx,
+    )
     for (let [key, route] of Object.entries(ctx.reactRouterConfig.routes)) {
-      let sourceExports = routeManifestExports[key];
+      let sourceExports = routeManifestExports[key]
       routes[key] = {
         id: route.id,
         parentId: route.parentId,
@@ -1634,60 +1822,58 @@ var reactRouterVitePlugin = () => {
           ctx.publicPath,
           `${resolveFileUrl(
             ctx,
-            resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
-          )}${ROUTE_ENTRY_QUERY_STRING}`
+            resolveRelativeRouteFilePath(route, ctx.reactRouterConfig),
+          )}${ROUTE_ENTRY_QUERY_STRING}`,
         ),
-        hasAction: sourceExports.includes("action"),
-        hasLoader: sourceExports.includes("loader"),
-        hasClientAction: sourceExports.includes("clientAction"),
-        hasClientLoader: sourceExports.includes("clientLoader"),
-        hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
-        imports: []
-      };
+        hasAction: sourceExports.includes('action'),
+        hasLoader: sourceExports.includes('loader'),
+        hasClientAction: sourceExports.includes('clientAction'),
+        hasClientLoader: sourceExports.includes('clientLoader'),
+        hasErrorBoundary: sourceExports.includes('ErrorBoundary'),
+        imports: [],
+      }
     }
     return {
       version: String(Math.random()),
       url: combineURLs(ctx.publicPath, url(browserManifestId)),
       hmr: {
-        runtime: combineURLs(
-          ctx.publicPath,
-          url(injectHmrRuntimeId)
-        )
+        runtime: combineURLs(ctx.publicPath, url(injectHmrRuntimeId)),
       },
       entry: {
         module: combineURLs(
           ctx.publicPath,
-          resolveFileUrl(ctx, ctx.entryClientFilePath)
+          resolveFileUrl(ctx, ctx.entryClientFilePath),
         ),
-        imports: []
+        imports: [],
       },
-      routes
-    };
-  };
+      routes,
+    }
+  }
   return [
     {
-      name: "react-router",
+      name: 'react-router',
       config: async (_viteUserConfig, _viteConfigEnv) => {
-        await preloadViteEsm();
-        let vite2 = importViteEsmSync();
-        viteUserConfig = _viteUserConfig;
-        viteConfigEnv = _viteConfigEnv;
-        viteCommand = viteConfigEnv.command;
+        await preloadViteEsm()
+        let vite2 = importViteEsmSync()
+        viteUserConfig = _viteUserConfig
+        viteConfigEnv = _viteConfigEnv
+        viteCommand = viteConfigEnv.command
         logger = vite2.createLogger(viteUserConfig.logLevel, {
-          prefix: "[react-router]"
-        });
-        rootDirectory = viteUserConfig.root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
-        if (viteCommand === "serve") {
+          prefix: '[react-router]',
+        })
+        rootDirectory =
+          viteUserConfig.root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd()
+        if (viteCommand === 'serve') {
           typegenWatcherPromise = watch(rootDirectory, {
             // ignore `info` logs from typegen since they are redundant when Vite plugin logs are active
-            logger: vite2.createLogger("warn", { prefix: "[react-router]" })
-          });
+            logger: vite2.createLogger('warn', { prefix: '[react-router]' }),
+          })
         }
         reactRouterConfigLoader = await createConfigLoader({
           rootDirectory,
-          watch: viteCommand === "serve"
-        });
-        await updatePluginContext();
+          watch: viteCommand === 'serve',
+        })
+        await updatePluginContext()
         Object.assign(
           process.env,
           vite2.loadEnv(
@@ -1696,75 +1882,85 @@ var reactRouterVitePlugin = () => {
             // We override default prefix of "VITE_" with a blank string since
             // we're targeting the server, so we want to load all environment
             // variables, not just those explicitly marked for the client
-            ""
-          )
-        );
+            '',
+          ),
+        )
         let baseRollupOptions = {
           // Silence Rollup "use client" warnings
           // Adapted from https://github.com/vitejs/vite-plugin-react/pull/144
           onwarn(warning, defaultHandler) {
-            if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
-              return;
+            if (
+              warning.code === 'MODULE_LEVEL_DIRECTIVE' &&
+              warning.message.includes('use client')
+            ) {
+              return
             }
             if (viteUserConfig.build?.rollupOptions?.onwarn) {
-              viteUserConfig.build.rollupOptions.onwarn(
-                warning,
-                defaultHandler
-              );
+              viteUserConfig.build.rollupOptions.onwarn(warning, defaultHandler)
             } else {
-              defaultHandler(warning);
+              defaultHandler(warning)
             }
-          }
-        };
+          },
+        }
         return {
           __reactRouterPluginContext: ctx,
-          appType: viteCommand === "serve" && viteConfigEnv.mode === "production" && ctx.reactRouterConfig.ssr === false ? "spa" : "custom",
+          appType:
+            viteCommand === 'serve' &&
+            viteConfigEnv.mode === 'production' &&
+            ctx.reactRouterConfig.ssr === false
+              ? 'spa'
+              : 'custom',
           ssr: {
             external: ssrExternals,
             resolve: {
-              conditions: viteCommand === "build" ? [] : ["development"],
-              externalConditions: viteCommand === "build" ? [] : ["development"]
-            }
+              conditions: viteCommand === 'build' ? [] : ['development'],
+              externalConditions:
+                viteCommand === 'build' ? [] : ['development'],
+            },
           },
           optimizeDeps: {
-            entries: ctx.reactRouterConfig.future.unstable_optimizeDeps ? [
-              ctx.entryClientFilePath,
-              ...Object.values(ctx.reactRouterConfig.routes).map(
-                (route) => path4.join(ctx.reactRouterConfig.appDirectory, route.file)
-              )
-            ] : [],
+            entries: ctx.reactRouterConfig.future.unstable_optimizeDeps
+              ? [
+                  ctx.entryClientFilePath,
+                  ...Object.values(ctx.reactRouterConfig.routes).map(route =>
+                    path4.join(ctx.reactRouterConfig.appDirectory, route.file),
+                  ),
+                ]
+              : [],
             include: [
               // Pre-bundle React dependencies to avoid React duplicates,
               // even if React dependencies are not direct dependencies.
               // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
-              "react",
-              "react/jsx-runtime",
-              "react/jsx-dev-runtime",
-              "react-dom",
-              "react-dom/client",
+              'react',
+              'react/jsx-runtime',
+              'react/jsx-dev-runtime',
+              'react-dom',
+              'react-dom/client',
               // Pre-bundle router dependencies to avoid router duplicates.
               // Mismatching routers cause `Error: You must render this element inside a <Remix> element`.
-              "react-router",
-              "react-router/dom",
+              'react-router',
+              'react-router/dom',
               // Check to avoid "Failed to resolve dependency: react-router-dom, present in 'optimizeDeps.include'"
-              ...hasDependency("react-router-dom") ? ["react-router-dom"] : []
-            ]
+              ...(hasDependency('react-router-dom')
+                ? ['react-router-dom']
+                : []),
+            ],
           },
           esbuild: {
-            jsx: "automatic",
-            jsxDev: viteCommand !== "build"
+            jsx: 'automatic',
+            jsxDev: viteCommand !== 'build',
           },
           resolve: {
             dedupe: [
               // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
-              "react",
-              "react-dom",
+              'react',
+              'react-dom',
               // see description for `optimizeDeps.include`
-              "react-router",
-              "react-router/dom",
-              "react-router-dom"
+              'react-router',
+              'react-router/dom',
+              'react-router-dom',
             ],
-            conditions: viteCommand === "build" ? [] : ["development"]
+            conditions: viteCommand === 'build' ? [] : ['development'],
           },
           base: viteUserConfig.base,
           // When consumer provides an allow list for files that can be read by
@@ -1772,135 +1968,170 @@ var reactRouterVitePlugin = () => {
           // If we don't do this and a default entry file is used, the server
           // will throw an error that the file is not allowed to be read.
           // https://vitejs.dev/config/server-options#server-fs-allow
-          server: viteUserConfig.server?.fs?.allow ? { fs: { allow: defaultEntries } } : void 0,
+          server: viteUserConfig.server?.fs?.allow
+            ? { fs: { allow: defaultEntries } }
+            : void 0,
           // Vite config options for building
-          ...viteCommand === "build" ? {
-            build: {
-              cssMinify: viteUserConfig.build?.cssMinify ?? true,
-              ...!viteConfigEnv.isSsrBuild ? {
-                manifest: true,
-                outDir: getClientBuildDirectory(ctx.reactRouterConfig),
-                rollupOptions: {
-                  ...baseRollupOptions,
-                  preserveEntrySignatures: "exports-only",
-                  input: [
-                    ctx.entryClientFilePath,
-                    ...Object.values(ctx.reactRouterConfig.routes).map(
-                      (route) => `${path4.resolve(
-                        ctx.reactRouterConfig.appDirectory,
-                        route.file
-                      )}${ROUTE_ENTRY_QUERY_STRING}`
-                    )
-                  ]
-                }
-              } : {
-                // We move SSR-only assets to client assets. Note that the
-                // SSR build can also emit code-split JS files (e.g. by
-                // dynamic import) under the same assets directory
-                // regardless of "ssrEmitAssets" option, so we also need to
-                // keep these JS files have to be kept as-is.
-                ssrEmitAssets: true,
-                copyPublicDir: false,
-                // Assets in the public directory are only used by the client
-                manifest: true,
-                // We need the manifest to detect SSR-only assets
-                outDir: getServerBuildDirectory(ctx),
-                rollupOptions: {
-                  ...baseRollupOptions,
-                  preserveEntrySignatures: "exports-only",
-                  input: viteUserConfig.build?.rollupOptions?.input ?? serverBuildId,
-                  output: {
-                    entryFileNames: ctx.reactRouterConfig.serverBuildFile,
-                    format: ctx.reactRouterConfig.serverModuleFormat
-                  }
-                }
+          ...(viteCommand === 'build'
+            ? {
+                build: {
+                  cssMinify: viteUserConfig.build?.cssMinify ?? true,
+                  ...(!viteConfigEnv.isSsrBuild
+                    ? {
+                        manifest: true,
+                        outDir: getClientBuildDirectory(ctx.reactRouterConfig),
+                        rollupOptions: {
+                          ...baseRollupOptions,
+                          preserveEntrySignatures: 'exports-only',
+                          input: [
+                            ctx.entryClientFilePath,
+                            ...Object.values(ctx.reactRouterConfig.routes).map(
+                              route =>
+                                `${path4.resolve(
+                                  ctx.reactRouterConfig.appDirectory,
+                                  route.file,
+                                )}${ROUTE_ENTRY_QUERY_STRING}`,
+                            ),
+                          ],
+                        },
+                      }
+                    : {
+                        // We move SSR-only assets to client assets. Note that the
+                        // SSR build can also emit code-split JS files (e.g. by
+                        // dynamic import) under the same assets directory
+                        // regardless of "ssrEmitAssets" option, so we also need to
+                        // keep these JS files have to be kept as-is.
+                        ssrEmitAssets: true,
+                        copyPublicDir: false,
+                        // Assets in the public directory are only used by the client
+                        manifest: true,
+                        // We need the manifest to detect SSR-only assets
+                        outDir: getServerBuildDirectory(ctx),
+                        rollupOptions: {
+                          ...baseRollupOptions,
+                          preserveEntrySignatures: 'exports-only',
+                          input:
+                            viteUserConfig.build?.rollupOptions?.input ??
+                            serverBuildId,
+                          output: {
+                            entryFileNames:
+                              ctx.reactRouterConfig.serverBuildFile,
+                            format: ctx.reactRouterConfig.serverModuleFormat,
+                          },
+                        },
+                      }),
+                },
               }
-            }
-          } : void 0,
+            : void 0),
           // Vite config options for SPA preview mode
-          ...viteCommand === "serve" && ctx.reactRouterConfig.ssr === false ? {
-            build: {
-              manifest: true,
-              outDir: getClientBuildDirectory(ctx.reactRouterConfig)
-            }
-          } : void 0
-        };
+          ...(viteCommand === 'serve' && ctx.reactRouterConfig.ssr === false
+            ? {
+                build: {
+                  manifest: true,
+                  outDir: getClientBuildDirectory(ctx.reactRouterConfig),
+                },
+              }
+            : void 0),
+        }
       },
       async configResolved(resolvedViteConfig) {
-        await import_es_module_lexer.init;
-        viteConfig = resolvedViteConfig;
-        invariant(viteConfig);
+        await import_es_module_lexer.init
+        viteConfig = resolvedViteConfig
+        invariant(viteConfig)
         if (!viteConfig.configFile) {
           throw new Error(
-            "The React Router Vite plugin requires the use of a Vite config file"
-          );
+            'The React Router Vite plugin requires the use of a Vite config file',
+          )
         }
-        let vite2 = importViteEsmSync();
+        let vite2 = importViteEsmSync()
         let childCompilerConfigFile = await vite2.loadConfigFromFile(
           {
             command: viteConfig.command,
             mode: viteConfig.mode,
-            isSsrBuild: ctx.isSsrBuild
+            isSsrBuild: ctx.isSsrBuild,
           },
-          viteConfig.configFile
-        );
+          viteConfig.configFile,
+        )
         invariant(
           childCompilerConfigFile,
-          "Vite config file was unable to be resolved for React Router child compiler"
-        );
+          'Vite config file was unable to be resolved for React Router child compiler',
+        )
         let rollupPrePlugins = [
-          { pluginName: "@mdx-js/rollup", displayName: "@mdx-js/rollup" }
-        ];
+          { pluginName: '@mdx-js/rollup', displayName: '@mdx-js/rollup' },
+        ]
         for (let prePlugin of rollupPrePlugins) {
-          let prePluginIndex = pluginIndex(prePlugin.pluginName);
-          if (prePluginIndex >= 0 && prePluginIndex > pluginIndex("react-router")) {
+          let prePluginIndex = pluginIndex(prePlugin.pluginName)
+          if (
+            prePluginIndex >= 0 &&
+            prePluginIndex > pluginIndex('react-router')
+          ) {
             throw new Error(
-              `The "${prePlugin.displayName}" plugin should be placed before the React Router plugin in your Vite config file`
-            );
+              `The "${prePlugin.displayName}" plugin should be placed before the React Router plugin in your Vite config file`,
+            )
           }
         }
         viteChildCompiler = await vite2.createServer({
           ...viteUserConfig,
           mode: viteConfig.mode,
           server: {
-            watch: viteConfig.command === "build" ? null : void 0,
+            watch: viteConfig.command === 'build' ? null : void 0,
             preTransformRequests: false,
-            hmr: false
+            hmr: false,
           },
           configFile: false,
           envFile: false,
           plugins: [
-            ...(childCompilerConfigFile.config.plugins ?? []).flat().filter(
-              (plugin2) => typeof plugin2 === "object" && plugin2 !== null && "name" in plugin2 && plugin2.name !== "react-router" && plugin2.name !== "react-router-route-exports" && plugin2.name !== "react-router-hmr-updates"
-            )
-          ]
-        });
-        await viteChildCompiler.pluginContainer.buildStart({});
+            ...(childCompilerConfigFile.config.plugins ?? [])
+              .flat()
+              .filter(
+                plugin2 =>
+                  typeof plugin2 === 'object' &&
+                  plugin2 !== null &&
+                  'name' in plugin2 &&
+                  plugin2.name !== 'react-router' &&
+                  plugin2.name !== 'react-router-route-exports' &&
+                  plugin2.name !== 'react-router-hmr-updates',
+              ),
+          ],
+        })
+        await viteChildCompiler.pluginContainer.buildStart({})
       },
       async transform(code, id2) {
         if (isCssModulesFile(id2)) {
-          cssModulesManifest[id2] = code;
+          cssModulesManifest[id2] = code
         }
       },
       buildStart() {
-        invariant(viteConfig);
-        if (viteCommand === "build" && viteConfig.mode === "production" && !viteConfig.build.ssr && viteConfig.build.sourcemap) {
+        invariant(viteConfig)
+        if (
+          viteCommand === 'build' &&
+          viteConfig.mode === 'production' &&
+          !viteConfig.build.ssr &&
+          viteConfig.build.sourcemap
+        ) {
           viteConfig.logger.warn(
             import_picocolors3.default.yellow(
-              "\n" + import_picocolors3.default.bold("  \u26A0\uFE0F  Source maps are enabled in production\n") + [
-                "This makes your server code publicly",
-                "visible in the browser. This is highly",
-                "discouraged! If you insist, ensure that",
-                "you are using environment variables for",
-                "secrets and not hard-coding them in",
-                "your source code."
-              ].map((line) => "     " + line).join("\n") + "\n"
-            )
-          );
+              '\n' +
+                import_picocolors3.default.bold(
+                  '  \u26A0\uFE0F  Source maps are enabled in production\n',
+                ) +
+                [
+                  'This makes your server code publicly',
+                  'visible in the browser. This is highly',
+                  'discouraged! If you insist, ensure that',
+                  'you are using environment variables for',
+                  'secrets and not hard-coding them in',
+                  'your source code.',
+                ]
+                  .map(line => '     ' + line)
+                  .join('\n') +
+                '\n',
+            ),
+          )
         }
       },
       async configureServer(viteDevServer) {
-        (0, import_react_router2.unstable_setDevServerHooks)({
+        ;(0, import_react_router2.unstable_setDevServerHooks)({
           // Give the request handler access to the critical CSS in dev to avoid a
           // flash of unstyled content since Vite injects CSS file contents via JS
           getCriticalCss: async (build, url3) => {
@@ -1911,367 +2142,401 @@ var reactRouterVitePlugin = () => {
               viteDevServer,
               cssModulesManifest,
               build,
-              url: url3
-            });
+              url: url3,
+            })
           },
           // If an error is caught within the request handler, let Vite fix the
           // stack trace so it maps back to the actual source code
-          processRequestError: (error) => {
+          processRequestError: error => {
             if (error instanceof Error) {
-              viteDevServer.ssrFixStacktrace(error);
+              viteDevServer.ssrFixStacktrace(error)
             }
-          }
-        });
+          },
+        })
         reactRouterConfigLoader.onChange(
           async ({
             result,
             configCodeUpdated,
             configChanged,
-            routeConfigChanged
+            routeConfigChanged,
           }) => {
             if (!result.ok) {
-              invalidateVirtualModules(viteDevServer);
+              invalidateVirtualModules(viteDevServer)
               logger.error(result.error, {
                 clear: true,
-                timestamp: true
-              });
-              return;
+                timestamp: true,
+              })
+              return
             }
             if (routeConfigChanged) {
-              logger.info(import_picocolors3.default.green("Route config changed."), {
-                clear: true,
-                timestamp: true
-              });
+              logger.info(
+                import_picocolors3.default.green('Route config changed.'),
+                {
+                  clear: true,
+                  timestamp: true,
+                },
+              )
             } else if (configCodeUpdated) {
-              logger.info(import_picocolors3.default.green("Config updated."), {
+              logger.info(import_picocolors3.default.green('Config updated.'), {
                 clear: true,
-                timestamp: true
-              });
+                timestamp: true,
+              })
             }
-            await updatePluginContext();
+            await updatePluginContext()
             if (configChanged) {
-              invalidateVirtualModules(viteDevServer);
+              invalidateVirtualModules(viteDevServer)
             }
-          }
-        );
+          },
+        )
         return () => {
           if (!viteDevServer.config.server.middlewareMode) {
             viteDevServer.middlewares.use(async (req, res, next) => {
               try {
-                let build = await viteDevServer.ssrLoadModule(
-                  serverBuildId
-                );
-                let handler = (0, import_react_router2.createRequestHandler)(build, "development");
+                let build = await viteDevServer.ssrLoadModule(serverBuildId)
+                let handler = (0, import_react_router2.createRequestHandler)(
+                  build,
+                  'development',
+                )
                 let nodeHandler = async (nodeReq, nodeRes) => {
-                  let req2 = fromNodeRequest(nodeReq, nodeRes);
+                  let req2 = fromNodeRequest(nodeReq, nodeRes)
                   let res2 = await handler(
                     req2,
-                    await reactRouterDevLoadContext(req2)
-                  );
-                  await toNodeRequest(res2, nodeRes);
-                };
-                await nodeHandler(req, res);
+                    await reactRouterDevLoadContext(req2),
+                  )
+                  await toNodeRequest(res2, nodeRes)
+                }
+                await nodeHandler(req, res)
               } catch (error) {
-                next(error);
+                next(error)
               }
-            });
+            })
           }
-        };
+        }
       },
       writeBundle: {
         // After the SSR build is finished, we inspect the Vite manifest for
         // the SSR build and move server-only assets to client assets directory
         async handler() {
           if (!ctx.isSsrBuild) {
-            return;
+            return
           }
-          invariant(viteConfig);
+          invariant(viteConfig)
           let clientBuildDirectory = getClientBuildDirectory(
-            ctx.reactRouterConfig
-          );
-          let serverBuildDirectory = getServerBuildDirectory(ctx);
-          let ssrViteManifest = await loadViteManifest(serverBuildDirectory);
-          let ssrAssetPaths = getViteManifestAssetPaths(ssrViteManifest);
-          let movedAssetPaths = [];
+            ctx.reactRouterConfig,
+          )
+          let serverBuildDirectory = getServerBuildDirectory(ctx)
+          let ssrViteManifest = await loadViteManifest(serverBuildDirectory)
+          let ssrAssetPaths = getViteManifestAssetPaths(ssrViteManifest)
+          let movedAssetPaths = []
           for (let ssrAssetPath of ssrAssetPaths) {
-            let src = path4.join(serverBuildDirectory, ssrAssetPath);
-            let dest = path4.join(clientBuildDirectory, ssrAssetPath);
+            let src = path4.join(serverBuildDirectory, ssrAssetPath)
+            let dest = path4.join(clientBuildDirectory, ssrAssetPath)
             if (!fse.existsSync(dest)) {
-              await fse.move(src, dest);
-              movedAssetPaths.push(dest);
+              await fse.move(src, dest)
+              movedAssetPaths.push(dest)
             } else {
-              await fse.remove(src);
+              await fse.remove(src)
             }
           }
           let ssrCssPaths = Object.values(ssrViteManifest).flatMap(
-            (chunk) => chunk.css ?? []
-          );
+            chunk => chunk.css ?? [],
+          )
           await Promise.all(
-            ssrCssPaths.map(
-              (cssPath) => fse.remove(path4.join(serverBuildDirectory, cssPath))
-            )
-          );
+            ssrCssPaths.map(cssPath =>
+              fse.remove(path4.join(serverBuildDirectory, cssPath)),
+            ),
+          )
           if (movedAssetPaths.length) {
             viteConfig.logger.info(
               [
-                "",
-                `${import_picocolors3.default.green("\u2713")} ${movedAssetPaths.length} asset${movedAssetPaths.length > 1 ? "s" : ""} moved from React Router server build to client assets.`,
-                ...movedAssetPaths.map(
-                  (movedAssetPath) => import_picocolors3.default.dim(path4.relative(ctx.rootDirectory, movedAssetPath))
+                '',
+                `${import_picocolors3.default.green('\u2713')} ${movedAssetPaths.length} asset${movedAssetPaths.length > 1 ? 's' : ''} moved from React Router server build to client assets.`,
+                ...movedAssetPaths.map(movedAssetPath =>
+                  import_picocolors3.default.dim(
+                    path4.relative(ctx.rootDirectory, movedAssetPath),
+                  ),
                 ),
-                ""
-              ].join("\n")
-            );
+                '',
+              ].join('\n'),
+            )
           }
-          if (ctx.reactRouterConfig.prerender != null && ctx.reactRouterConfig.prerender !== false) {
+          if (
+            ctx.reactRouterConfig.prerender != null &&
+            ctx.reactRouterConfig.prerender !== false
+          ) {
             await handlePrerender(
               viteConfig,
               ctx.reactRouterConfig,
               serverBuildDirectory,
-              clientBuildDirectory
-            );
+              clientBuildDirectory,
+            )
           }
           if (!ctx.reactRouterConfig.ssr) {
             await handleSpaMode(
               viteConfig,
               ctx.reactRouterConfig,
               serverBuildDirectory,
-              clientBuildDirectory
-            );
+              clientBuildDirectory,
+            )
           }
           if (!ctx.reactRouterConfig.ssr) {
             viteConfig.logger.info(
               [
-                "Removing the server build in",
+                'Removing the server build in',
                 import_picocolors3.default.green(serverBuildDirectory),
-                "due to ssr:false"
-              ].join(" ")
-            );
-            fse.removeSync(serverBuildDirectory);
+                'due to ssr:false',
+              ].join(' '),
+            )
+            fse.removeSync(serverBuildDirectory)
           }
-        }
+        },
       },
       async buildEnd() {
-        await viteChildCompiler?.close();
-        await reactRouterConfigLoader.close();
-        let typegenWatcher = await typegenWatcherPromise;
-        await typegenWatcher?.close();
-      }
+        await viteChildCompiler?.close()
+        await reactRouterConfigLoader.close()
+        let typegenWatcher = await typegenWatcherPromise
+        await typegenWatcher?.close()
+      },
     },
     {
-      name: "react-router-route-entry",
-      enforce: "pre",
+      name: 'react-router-route-entry',
+      enforce: 'pre',
       async transform(_code, id2, options) {
-        if (!isRouteEntry(id2)) return;
-        let routeModuleId = id2.replace(ROUTE_ENTRY_QUERY_STRING, "");
-        let routeFileName = path4.basename(routeModuleId);
+        if (!isRouteEntry(id2)) return
+        let routeModuleId = id2.replace(ROUTE_ENTRY_QUERY_STRING, '')
+        let routeFileName = path4.basename(routeModuleId)
         let sourceExports = await getRouteModuleExports(
           viteChildCompiler,
           ctx,
-          routeModuleId
-        );
-        let reexports = sourceExports.filter(
-          (exportName) => options?.ssr && SERVER_ONLY_ROUTE_EXPORTS.includes(exportName) || CLIENT_ROUTE_EXPORTS.includes(exportName)
-        ).join(", ");
-        return `export { ${reexports} } from "./${routeFileName}";`;
-      }
+          routeModuleId,
+        )
+        let reexports = sourceExports
+          .filter(
+            exportName =>
+              (options?.ssr &&
+                SERVER_ONLY_ROUTE_EXPORTS.includes(exportName)) ||
+              CLIENT_ROUTE_EXPORTS.includes(exportName),
+          )
+          .join(', ')
+        return `export { ${reexports} } from "./${routeFileName}";`
+      },
     },
     {
-      name: "react-router-virtual-modules",
-      enforce: "pre",
+      name: 'react-router-virtual-modules',
+      enforce: 'pre',
       resolveId(id2) {
-        if (vmods.includes(id2)) return resolve3(id2);
+        if (vmods.includes(id2)) return resolve3(id2)
       },
       async load(id2) {
         switch (id2) {
           case resolve3(serverBuildId): {
-            return await getServerEntry();
+            return await getServerEntry()
           }
           case resolve3(serverManifestId): {
-            let reactRouterManifest = ctx.isSsrBuild ? await ctx.getReactRouterServerManifest() : await getReactRouterManifestForDev();
-            return `export default ${(0, import_jsesc.default)(reactRouterManifest, {
-              es6: true
-            })};`;
+            let reactRouterManifest = ctx.isSsrBuild
+              ? await ctx.getReactRouterServerManifest()
+              : await getReactRouterManifestForDev()
+            return `export default ${(0, import_jsesc.default)(
+              reactRouterManifest,
+              {
+                es6: true,
+              },
+            )};`
           }
           case resolve3(browserManifestId): {
-            if (viteCommand === "build") {
-              throw new Error("This module only exists in development");
+            if (viteCommand === 'build') {
+              throw new Error('This module only exists in development')
             }
-            let reactRouterManifest = await getReactRouterManifestForDev();
-            let reactRouterManifestString = (0, import_jsesc.default)(reactRouterManifest, {
-              es6: true
-            });
-            return `window.__reactRouterManifest=${reactRouterManifestString};`;
+            let reactRouterManifest = await getReactRouterManifestForDev()
+            let reactRouterManifestString = (0, import_jsesc.default)(
+              reactRouterManifest,
+              {
+                es6: true,
+              },
+            )
+            return `window.__reactRouterManifest=${reactRouterManifestString};`
           }
         }
-      }
+      },
     },
     {
-      name: "react-router-dot-server",
-      enforce: "pre",
+      name: 'react-router-dot-server',
+      enforce: 'pre',
       async resolveId(id2, importer, options) {
-        let isOptimizeDeps = viteCommand === "serve" && options?.scan === true;
-        if (isOptimizeDeps || options?.ssr) return;
-        let isResolving = options?.custom?.["react-router-dot-server"] ?? false;
-        if (isResolving) return;
-        options.custom = { ...options.custom, "react-router-dot-server": true };
-        let resolved = await this.resolve(id2, importer, options);
-        if (!resolved) return;
-        let serverFileRE = /\.server(\.[cm]?[jt]sx?)?$/;
-        let serverDirRE = /\/\.server\//;
-        let isDotServer = serverFileRE.test(resolved.id) || serverDirRE.test(resolved.id);
-        if (!isDotServer) return;
-        if (!importer) return;
-        if (viteCommand !== "build" && importer.endsWith(".html")) {
-          return;
+        let isOptimizeDeps = viteCommand === 'serve' && options?.scan === true
+        if (isOptimizeDeps || options?.ssr) return
+        let isResolving = options?.custom?.['react-router-dot-server'] ?? false
+        if (isResolving) return
+        options.custom = { ...options.custom, 'react-router-dot-server': true }
+        let resolved = await this.resolve(id2, importer, options)
+        if (!resolved) return
+        let serverFileRE = /\.server(\.[cm]?[jt]sx?)?$/
+        let serverDirRE = /\/\.server\//
+        let isDotServer =
+          serverFileRE.test(resolved.id) || serverDirRE.test(resolved.id)
+        if (!isDotServer) return
+        if (!importer) return
+        if (viteCommand !== 'build' && importer.endsWith('.html')) {
+          return
         }
-        let vite2 = importViteEsmSync();
+        let vite2 = importViteEsmSync()
         let importerShort = vite2.normalizePath(
-          path4.relative(ctx.rootDirectory, importer)
-        );
-        let isRoute = getRoute(ctx.reactRouterConfig, importer);
+          path4.relative(ctx.rootDirectory, importer),
+        )
+        let isRoute = getRoute(ctx.reactRouterConfig, importer)
         if (isRoute) {
           let serverOnlyExports = SERVER_ONLY_ROUTE_EXPORTS.map(
-            (xport) => `\`${xport}\``
-          ).join(", ");
+            xport => `\`${xport}\``,
+          ).join(', ')
           throw Error(
             [
-              import_picocolors3.default.red(`Server-only module referenced by client`),
-              "",
+              import_picocolors3.default.red(
+                `Server-only module referenced by client`,
+              ),
+              '',
               `    '${id2}' imported by route '${importerShort}'`,
-              "",
+              '',
               `  React Router automatically removes server-code from these exports:`,
               `    ${serverOnlyExports}`,
-              "",
+              '',
               `  But other route exports in '${importerShort}' depend on '${id2}'.`,
-              "",
-              "  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code",
-              ""
-            ].join("\n")
-          );
+              '',
+              '  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code',
+              '',
+            ].join('\n'),
+          )
         }
         throw Error(
           [
-            import_picocolors3.default.red(`Server-only module referenced by client`),
-            "",
+            import_picocolors3.default.red(
+              `Server-only module referenced by client`,
+            ),
+            '',
             `    '${id2}' imported by '${importerShort}'`,
-            "",
-            "  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code",
-            ""
-          ].join("\n")
-        );
-      }
+            '',
+            '  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code',
+            '',
+          ].join('\n'),
+        )
+      },
     },
     {
-      name: "react-router-dot-client",
+      name: 'react-router-dot-client',
       async transform(code, id2, options) {
-        if (!options?.ssr) return;
-        let clientFileRE = /\.client(\.[cm]?[jt]sx?)?$/;
-        let clientDirRE = /\/\.client\//;
+        if (!options?.ssr) return
+        let clientFileRE = /\.client(\.[cm]?[jt]sx?)?$/
+        let clientDirRE = /\/\.client\//
         if (clientFileRE.test(id2) || clientDirRE.test(id2)) {
-          let exports2 = (0, import_es_module_lexer.parse)(code)[1];
+          let exports2 = (0, import_es_module_lexer.parse)(code)[1]
           return {
-            code: exports2.map(
-              ({ n: name }) => name === "default" ? "export default undefined;" : `export const ${name} = undefined;`
-            ).join("\n"),
-            map: null
-          };
+            code: exports2
+              .map(({ n: name }) =>
+                name === 'default'
+                  ? 'export default undefined;'
+                  : `export const ${name} = undefined;`,
+              )
+              .join('\n'),
+            map: null,
+          }
         }
-      }
+      },
     },
     plugin,
     {
-      name: "react-router-route-exports",
+      name: 'react-router-route-exports',
       async transform(code, id2, options) {
-        let route = getRoute(ctx.reactRouterConfig, id2);
-        if (!route) return;
+        let route = getRoute(ctx.reactRouterConfig, id2)
+        if (!route) return
         if (!options?.ssr && !ctx.reactRouterConfig.ssr) {
-          let serverOnlyExports = (0, import_es_module_lexer.parse)(code)[1].map((exp) => exp.n).filter((exp) => SERVER_ONLY_ROUTE_EXPORTS.includes(exp));
+          let serverOnlyExports = (0, import_es_module_lexer.parse)(code)[1]
+            .map(exp => exp.n)
+            .filter(exp => SERVER_ONLY_ROUTE_EXPORTS.includes(exp))
           if (serverOnlyExports.length > 0) {
-            let str = serverOnlyExports.map((e) => `\`${e}\``).join(", ");
-            let message = `SPA Mode: ${serverOnlyExports.length} invalid route export(s) in \`${route.file}\`: ${str}. See https://remix.run/guides/spa-mode for more information.`;
-            throw Error(message);
+            let str = serverOnlyExports.map(e => `\`${e}\``).join(', ')
+            let message = `SPA Mode: ${serverOnlyExports.length} invalid route export(s) in \`${route.file}\`: ${str}. See https://remix.run/guides/spa-mode for more information.`
+            throw Error(message)
           }
-          if (route.id !== "root") {
-            let hasHydrateFallback = (0, import_es_module_lexer.parse)(code)[1].map((exp) => exp.n).some((exp) => exp === "HydrateFallback");
+          if (route.id !== 'root') {
+            let hasHydrateFallback = (0, import_es_module_lexer.parse)(code)[1]
+              .map(exp => exp.n)
+              .some(exp => exp === 'HydrateFallback')
             if (hasHydrateFallback) {
-              let message = `SPA Mode: Invalid \`HydrateFallback\` export found in \`${route.file}\`. \`HydrateFallback\` is only permitted on the root route in SPA Mode. See https://remix.run/guides/spa-mode for more information.`;
-              throw Error(message);
+              let message = `SPA Mode: Invalid \`HydrateFallback\` export found in \`${route.file}\`. \`HydrateFallback\` is only permitted on the root route in SPA Mode. See https://remix.run/guides/spa-mode for more information.`
+              throw Error(message)
             }
           }
         }
-        let [filepath] = id2.split("?");
-        let ast = (0, import_parser.parse)(code, { sourceType: "module" });
+        let [filepath] = id2.split('?')
+        let ast = (0, import_parser.parse)(code, { sourceType: 'module' })
         if (!options?.ssr) {
-          removeExports(ast, SERVER_ONLY_ROUTE_EXPORTS);
+          removeExports(ast, SERVER_ONLY_ROUTE_EXPORTS)
         }
-        transform(ast);
+        transform(ast)
         return generate2(ast, {
           sourceMaps: true,
           filename: id2,
-          sourceFileName: filepath
-        });
-      }
+          sourceFileName: filepath,
+        })
+      },
     },
     {
-      name: "react-router-inject-hmr-runtime",
-      enforce: "pre",
+      name: 'react-router-inject-hmr-runtime',
+      enforce: 'pre',
       resolveId(id2) {
-        if (id2 === injectHmrRuntimeId)
-          return resolve3(injectHmrRuntimeId);
+        if (id2 === injectHmrRuntimeId) return resolve3(injectHmrRuntimeId)
       },
       async load(id2) {
-        if (id2 !== resolve3(injectHmrRuntimeId)) return;
+        if (id2 !== resolve3(injectHmrRuntimeId)) return
         return [
           `import RefreshRuntime from "${hmrRuntimeId}"`,
-          "RefreshRuntime.injectIntoGlobalHook(window)",
-          "window.$RefreshReg$ = () => {}",
-          "window.$RefreshSig$ = () => (type) => type",
-          "window.__vite_plugin_react_preamble_installed__ = true"
-        ].join("\n");
-      }
+          'RefreshRuntime.injectIntoGlobalHook(window)',
+          'window.$RefreshReg$ = () => {}',
+          'window.$RefreshSig$ = () => (type) => type',
+          'window.__vite_plugin_react_preamble_installed__ = true',
+        ].join('\n')
+      },
     },
     {
-      name: "react-router-hmr-runtime",
-      enforce: "pre",
+      name: 'react-router-hmr-runtime',
+      enforce: 'pre',
       resolveId(id2) {
-        if (id2 === hmrRuntimeId) return resolve3(hmrRuntimeId);
+        if (id2 === hmrRuntimeId) return resolve3(hmrRuntimeId)
       },
       async load(id2) {
-        if (id2 !== resolve3(hmrRuntimeId)) return;
+        if (id2 !== resolve3(hmrRuntimeId)) return
         let reactRefreshDir = path4.dirname(
-          require.resolve("react-refresh/package.json")
-        );
+          require.resolve('react-refresh/package.json'),
+        )
         let reactRefreshRuntimePath = path4.join(
           reactRefreshDir,
-          "cjs/react-refresh-runtime.development.js"
-        );
+          'cjs/react-refresh-runtime.development.js',
+        )
         return [
-          "const exports = {}",
-          await fse.readFile(reactRefreshRuntimePath, "utf8"),
+          'const exports = {}',
+          await fse.readFile(reactRefreshRuntimePath, 'utf8'),
           await fse.readFile(
-            require.resolve("./static/refresh-utils.cjs"),
-            "utf8"
+            require.resolve('./static/refresh-utils.cjs'),
+            'utf8',
           ),
-          "export default exports"
-        ].join("\n");
-      }
+          'export default exports',
+        ].join('\n')
+      },
     },
     {
-      name: "react-router-react-refresh-babel",
+      name: 'react-router-react-refresh-babel',
       async transform(code, id2, options) {
-        if (viteCommand !== "serve") return;
-        if (id2.includes("/node_modules/")) return;
-        let [filepath] = id2.split("?");
-        let extensionsRE = /\.(jsx?|tsx?|mdx?)$/;
-        if (!extensionsRE.test(filepath)) return;
-        let devRuntime = "react/jsx-dev-runtime";
-        let ssr = options?.ssr === true;
-        let isJSX = filepath.endsWith("x");
-        let useFastRefresh = !ssr && (isJSX || code.includes(devRuntime));
-        if (!useFastRefresh) return;
+        if (viteCommand !== 'serve') return
+        if (id2.includes('/node_modules/')) return
+        let [filepath] = id2.split('?')
+        let extensionsRE = /\.(jsx?|tsx?|mdx?)$/
+        if (!extensionsRE.test(filepath)) return
+        let devRuntime = 'react/jsx-dev-runtime'
+        let ssr = options?.ssr === true
+        let isJSX = filepath.endsWith('x')
+        let useFastRefresh = !ssr && (isJSX || code.includes(devRuntime))
+        if (!useFastRefresh) return
         if (isRouteEntry(id2)) {
-          return { code: addRefreshWrapper(ctx.reactRouterConfig, code, id2) };
+          return { code: addRefreshWrapper(ctx.reactRouterConfig, code, id2) }
         }
         let result = await babel.transformAsync(code, {
           babelrc: false,
@@ -2279,82 +2544,99 @@ var reactRouterVitePlugin = () => {
           filename: id2,
           sourceFileName: filepath,
           parserOpts: {
-            sourceType: "module",
-            allowAwaitOutsideFunction: true
+            sourceType: 'module',
+            allowAwaitOutsideFunction: true,
           },
-          plugins: [[require("react-refresh/babel"), { skipEnvCheck: true }]],
-          sourceMaps: true
-        });
-        if (result === null) return;
-        code = result.code;
-        let refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
+          plugins: [[require('react-refresh/babel'), { skipEnvCheck: true }]],
+          sourceMaps: true,
+        })
+        if (result === null) return
+        code = result.code
+        let refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/
         if (refreshContentRE.test(code)) {
-          code = addRefreshWrapper(ctx.reactRouterConfig, code, id2);
+          code = addRefreshWrapper(ctx.reactRouterConfig, code, id2)
         }
-        return { code, map: result.map };
-      }
+        return { code, map: result.map }
+      },
     },
     {
-      name: "react-router-hmr-updates",
+      name: 'react-router-hmr-updates',
       async handleHotUpdate({ server, file, modules, read }) {
-        let route = getRoute(ctx.reactRouterConfig, file);
-        let hmrEventData = { route: null };
+        let route = getRoute(ctx.reactRouterConfig, file)
+        let hmrEventData = { route: null }
         if (route) {
-          let serverManifest = (await server.ssrLoadModule(serverManifestId)).default;
-          let oldRouteMetadata = serverManifest.routes[route.id];
+          let serverManifest = (await server.ssrLoadModule(serverManifestId))
+            .default
+          let oldRouteMetadata = serverManifest.routes[route.id]
           let newRouteMetadata = await getRouteMetadata(
             ctx,
             viteChildCompiler,
             route,
-            read
-          );
-          hmrEventData.route = newRouteMetadata;
-          if (!oldRouteMetadata || [
-            "hasLoader",
-            "hasClientLoader",
-            "hasAction",
-            "hasClientAction",
-            "hasErrorBoundary"
-          ].some((key) => oldRouteMetadata[key] !== newRouteMetadata[key])) {
-            invalidateVirtualModules(server);
+            read,
+          )
+          hmrEventData.route = newRouteMetadata
+          if (
+            !oldRouteMetadata ||
+            [
+              'hasLoader',
+              'hasClientLoader',
+              'hasAction',
+              'hasClientAction',
+              'hasErrorBoundary',
+            ].some(key => oldRouteMetadata[key] !== newRouteMetadata[key])
+          ) {
+            invalidateVirtualModules(server)
           }
         }
         server.hot.send({
-          type: "custom",
-          event: "react-router:hmr",
-          data: hmrEventData
-        });
-        return modules;
-      }
-    }
-  ];
-};
+          type: 'custom',
+          event: 'react-router:hmr',
+          data: hmrEventData,
+        })
+        return modules
+      },
+    },
+  ]
+}
 function addRefreshWrapper(reactRouterConfig, code, id2) {
-  let route = getRoute(reactRouterConfig, id2);
-  let acceptExports = route || isRouteEntry(id2) ? [
-    "clientAction",
-    "clientLoader",
-    "handle",
-    "meta",
-    "links",
-    "shouldRevalidate"
-  ] : [];
-  return "\n\n" + withCommentBoundaries(
-    "REACT REFRESH HEADER",
-    REACT_REFRESH_HEADER.replaceAll("__SOURCE__", JSON.stringify(id2))
-  ) + "\n\n" + withCommentBoundaries("REACT REFRESH BODY", code) + "\n\n" + withCommentBoundaries(
-    "REACT REFRESH FOOTER",
-    REACT_REFRESH_FOOTER.replaceAll("__SOURCE__", JSON.stringify(id2)).replaceAll("__ACCEPT_EXPORTS__", JSON.stringify(acceptExports)).replaceAll("__ROUTE_ID__", JSON.stringify(route?.id))
-  ) + "\n";
+  let route = getRoute(reactRouterConfig, id2)
+  let acceptExports =
+    route || isRouteEntry(id2)
+      ? [
+          'clientAction',
+          'clientLoader',
+          'handle',
+          'meta',
+          'links',
+          'shouldRevalidate',
+        ]
+      : []
+  return (
+    '\n\n' +
+    withCommentBoundaries(
+      'REACT REFRESH HEADER',
+      REACT_REFRESH_HEADER.replaceAll('__SOURCE__', JSON.stringify(id2)),
+    ) +
+    '\n\n' +
+    withCommentBoundaries('REACT REFRESH BODY', code) +
+    '\n\n' +
+    withCommentBoundaries(
+      'REACT REFRESH FOOTER',
+      REACT_REFRESH_FOOTER.replaceAll('__SOURCE__', JSON.stringify(id2))
+        .replaceAll('__ACCEPT_EXPORTS__', JSON.stringify(acceptExports))
+        .replaceAll('__ROUTE_ID__', JSON.stringify(route?.id)),
+    ) +
+    '\n'
+  )
 }
 function withCommentBoundaries(label, text) {
-  let begin = `// [BEGIN] ${label} `;
-  begin += "-".repeat(80 - begin.length);
-  let end = `// [END] ${label} `;
-  end += "-".repeat(80 - end.length);
+  let begin = `// [BEGIN] ${label} `
+  begin += '-'.repeat(80 - begin.length)
+  let end = `// [END] ${label} `
+  end += '-'.repeat(80 - end.length)
   return `${begin}
 ${text}
-${end}`;
+${end}`
 }
 var REACT_REFRESH_HEADER = `
 import RefreshRuntime from "${hmrRuntimeId}";
@@ -2376,7 +2658,7 @@ if (import.meta.hot && !inWebWorker) {
     RefreshRuntime.register(type, __SOURCE__ + " " + id)
   };
   window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
-}`.trim();
+}`.trim()
 var REACT_REFRESH_FOOTER = `
 if (import.meta.hot && !inWebWorker) {
   window.$RefreshReg$ = prevRefreshReg;
@@ -2390,24 +2672,24 @@ if (import.meta.hot && !inWebWorker) {
       if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
     });
   });
-}`.trim();
+}`.trim()
 function getRoute(pluginConfig, file) {
-  let vite2 = importViteEsmSync();
+  let vite2 = importViteEsmSync()
   let routePath = vite2.normalizePath(
-    path4.relative(pluginConfig.appDirectory, file)
-  );
+    path4.relative(pluginConfig.appDirectory, file),
+  )
   let route = Object.values(pluginConfig.routes).find(
-    (r) => vite2.normalizePath(r.file) === routePath
-  );
-  return route;
+    r => vite2.normalizePath(r.file) === routePath,
+  )
+  return route
 }
 async function getRouteMetadata(ctx, viteChildCompiler, route, readRouteFile) {
   let sourceExports = await getRouteModuleExports(
     viteChildCompiler,
     ctx,
     route.file,
-    readRouteFile
-  );
+    readRouteFile,
+  )
   let info = {
     id: route.id,
     parentId: route.parentId,
@@ -2416,87 +2698,103 @@ async function getRouteMetadata(ctx, viteChildCompiler, route, readRouteFile) {
     caseSensitive: route.caseSensitive,
     url: combineURLs(
       ctx.publicPath,
-      "/" + path4.relative(
-        ctx.rootDirectory,
-        resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
-      )
+      '/' +
+        path4.relative(
+          ctx.rootDirectory,
+          resolveRelativeRouteFilePath(route, ctx.reactRouterConfig),
+        ),
     ),
     module: combineURLs(
       ctx.publicPath,
       `${resolveFileUrl(
         ctx,
-        resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
-      )}?import`
+        resolveRelativeRouteFilePath(route, ctx.reactRouterConfig),
+      )}?import`,
     ),
     // Ensure the Vite dev server responds with a JS module
-    hasAction: sourceExports.includes("action"),
-    hasClientAction: sourceExports.includes("clientAction"),
-    hasLoader: sourceExports.includes("loader"),
-    hasClientLoader: sourceExports.includes("clientLoader"),
-    hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
-    imports: []
-  };
-  return info;
+    hasAction: sourceExports.includes('action'),
+    hasClientAction: sourceExports.includes('clientAction'),
+    hasLoader: sourceExports.includes('loader'),
+    hasClientLoader: sourceExports.includes('clientLoader'),
+    hasErrorBoundary: sourceExports.includes('ErrorBoundary'),
+    imports: [],
+  }
+  return info
 }
-async function getPrerenderBuildAndHandler(viteConfig, reactRouterConfig, serverBuildDirectory) {
+async function getPrerenderBuildAndHandler(
+  viteConfig,
+  reactRouterConfig,
+  serverBuildDirectory,
+) {
   let serverBuildPath = path4.join(
     serverBuildDirectory,
-    reactRouterConfig.serverBuildFile
-  );
-  let build = await import(url2.pathToFileURL(serverBuildPath).toString());
-  let { createRequestHandler: createHandler } = await import("react-router");
+    reactRouterConfig.serverBuildFile,
+  )
+  let build = await import(url2.pathToFileURL(serverBuildPath).toString())
+  let { createRequestHandler: createHandler } = await import('react-router')
   return {
     build,
-    handler: createHandler(build, viteConfig.mode)
-  };
+    handler: createHandler(build, viteConfig.mode),
+  }
 }
-async function handleSpaMode(viteConfig, reactRouterConfig, serverBuildDirectory, clientBuildDirectory) {
+async function handleSpaMode(
+  viteConfig,
+  reactRouterConfig,
+  serverBuildDirectory,
+  clientBuildDirectory,
+) {
   let { handler } = await getPrerenderBuildAndHandler(
     viteConfig,
     reactRouterConfig,
-    serverBuildDirectory
-  );
-  let request = new Request(`http://localhost${reactRouterConfig.basename}`);
-  let response = await handler(request);
-  let html = await response.text();
-  validatePrerenderedResponse(response, html, "SPA Mode", "/");
-  validatePrerenderedHtml(html, "SPA Mode");
-  await fse.writeFile(path4.join(clientBuildDirectory, "index.html"), html);
+    serverBuildDirectory,
+  )
+  let request = new Request(`http://localhost${reactRouterConfig.basename}`)
+  let response = await handler(request)
+  let html = await response.text()
+  validatePrerenderedResponse(response, html, 'SPA Mode', '/')
+  validatePrerenderedHtml(html, 'SPA Mode')
+  await fse.writeFile(path4.join(clientBuildDirectory, 'index.html'), html)
   viteConfig.logger.info(
-    "SPA Mode: index.html has been written to your " + import_picocolors3.default.bold(path4.relative(process.cwd(), clientBuildDirectory)) + " directory"
-  );
+    'SPA Mode: index.html has been written to your ' +
+      import_picocolors3.default.bold(
+        path4.relative(process.cwd(), clientBuildDirectory),
+      ) +
+      ' directory',
+  )
 }
-async function handlePrerender(viteConfig, reactRouterConfig, serverBuildDirectory, clientBuildDirectory) {
+async function handlePrerender(
+  viteConfig,
+  reactRouterConfig,
+  serverBuildDirectory,
+  clientBuildDirectory,
+) {
   let { build, handler } = await getPrerenderBuildAndHandler(
     viteConfig,
     reactRouterConfig,
-    serverBuildDirectory
-  );
-  let routes = createPrerenderRoutes(build.routes);
-  let routesToPrerender;
-  if (typeof reactRouterConfig.prerender === "boolean") {
-    invariant(reactRouterConfig.prerender, "Expected prerender:true");
-    routesToPrerender = determineStaticPrerenderRoutes(
-      routes,
-      viteConfig,
-      true
-    );
-  } else if (typeof reactRouterConfig.prerender === "function") {
+    serverBuildDirectory,
+  )
+  let routes = createPrerenderRoutes(build.routes)
+  let routesToPrerender
+  if (typeof reactRouterConfig.prerender === 'boolean') {
+    invariant(reactRouterConfig.prerender, 'Expected prerender:true')
+    routesToPrerender = determineStaticPrerenderRoutes(routes, viteConfig, true)
+  } else if (typeof reactRouterConfig.prerender === 'function') {
     routesToPrerender = await reactRouterConfig.prerender({
-      getStaticPaths: () => determineStaticPrerenderRoutes(routes, viteConfig, false)
-    });
+      getStaticPaths: () =>
+        determineStaticPrerenderRoutes(routes, viteConfig, false),
+    })
   } else {
-    routesToPrerender = reactRouterConfig.prerender || ["/"];
+    routesToPrerender = reactRouterConfig.prerender || ['/']
   }
   let headers = {
     // Header that can be used in the loader to know if you're running at
     // build time or runtime
-    "X-React-Router-Prerender": "yes"
-  };
+    'X-React-Router-Prerender': 'yes',
+  }
   for (let path5 of routesToPrerender) {
-    let matches = (0, import_react_router2.matchRoutes)(routes, path5);
-    let hasLoaders = matches?.some((m) => m.route.loader);
-    let data;
+    let matches = (0, import_react_router2.matchRoutes)(routes, path5)
+    let hasLoaders = matches?.some(m => m.route.loader)
+    let data
     if (hasLoaders) {
       data = await prerenderData(
         handler,
@@ -2504,12 +2802,16 @@ async function handlePrerender(viteConfig, reactRouterConfig, serverBuildDirecto
         clientBuildDirectory,
         reactRouterConfig,
         viteConfig,
-        { headers }
-      );
+        { headers },
+      )
     }
-    let leafRoute = matches ? matches[matches.length - 1].route : null;
-    let manifestRoute = leafRoute ? build.routes[leafRoute.id]?.module : null;
-    let isResourceRoute = manifestRoute && !manifestRoute.default && !manifestRoute.ErrorBoundary && manifestRoute.loader;
+    let leafRoute = matches ? matches[matches.length - 1].route : null
+    let manifestRoute = leafRoute ? build.routes[leafRoute.id]?.module : null
+    let isResourceRoute =
+      manifestRoute &&
+      !manifestRoute.default &&
+      !manifestRoute.ErrorBoundary &&
+      manifestRoute.loader
     if (isResourceRoute) {
       await prerenderResourceRoute(
         handler,
@@ -2517,8 +2819,8 @@ async function handlePrerender(viteConfig, reactRouterConfig, serverBuildDirecto
         clientBuildDirectory,
         reactRouterConfig,
         viteConfig,
-        { headers }
-      );
+        { headers },
+      )
     } else {
       await prerenderRoute(
         handler,
@@ -2526,158 +2828,215 @@ async function handlePrerender(viteConfig, reactRouterConfig, serverBuildDirecto
         clientBuildDirectory,
         reactRouterConfig,
         viteConfig,
-        data ? {
-          headers: {
-            ...headers,
-            "X-React-Router-Prerender-Data": encodeURI(data)
-          }
-        } : { headers }
-      );
+        data
+          ? {
+              headers: {
+                ...headers,
+                'X-React-Router-Prerender-Data': encodeURI(data),
+              },
+            }
+          : { headers },
+      )
     }
   }
   await prerenderManifest(
     build,
     clientBuildDirectory,
     reactRouterConfig,
-    viteConfig
-  );
+    viteConfig,
+  )
 }
-function determineStaticPrerenderRoutes(routes, viteConfig, isBooleanUsage = false) {
-  let paths = ["/"];
-  let paramRoutes = [];
-  function recurse(subtree, prefix = "") {
+function determineStaticPrerenderRoutes(
+  routes,
+  viteConfig,
+  isBooleanUsage = false,
+) {
+  let paths = ['/']
+  let paramRoutes = []
+  function recurse(subtree, prefix = '') {
     for (let route of subtree) {
-      let newPath = [prefix, route.path].join("/").replace(/\/\/+/g, "/");
+      let newPath = [prefix, route.path].join('/').replace(/\/\/+/g, '/')
       if (route.path) {
-        let segments = route.path.split("/");
-        if (segments.some((s) => s.startsWith(":") || s === "*")) {
-          paramRoutes.push(route.path);
+        let segments = route.path.split('/')
+        if (segments.some(s => s.startsWith(':') || s === '*')) {
+          paramRoutes.push(route.path)
         } else {
-          paths.push(newPath);
+          paths.push(newPath)
         }
       }
       if (route.children) {
-        recurse(route.children, newPath);
+        recurse(route.children, newPath)
       }
     }
   }
-  recurse(routes);
+  recurse(routes)
   if (isBooleanUsage && paramRoutes.length > 0) {
     viteConfig.logger.warn(
       [
-        "\u26A0\uFE0F Paths with dynamic/splat params cannot be prerendered when using `prerender: true`.",
-        "You may want to use the `prerender()` API to prerender the following paths:",
-        ...paramRoutes.map((p) => "  - " + p)
-      ].join("\n")
-    );
+        '\u26A0\uFE0F Paths with dynamic/splat params cannot be prerendered when using `prerender: true`.',
+        'You may want to use the `prerender()` API to prerender the following paths:',
+        ...paramRoutes.map(p => '  - ' + p),
+      ].join('\n'),
+    )
   }
-  return paths.map((p) => p.replace(/\/\/+/g, "/").replace(/(.+)\/$/, "$1"));
-}
-async function prerenderData(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
-  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath === "/" ? "/_root.data" : `${prerenderPath.replace(/\/$/, "")}.data`}`.replace(/\/\/+/g, "/");
-  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
-  let response = await handler(request);
-  let data = await response.text();
-  validatePrerenderedResponse(response, data, "Prerender", normalizedPath);
-  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
-  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
-  await fse.ensureDir(path4.dirname(outfile));
-  await fse.outputFile(outfile, data);
-  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
-  return data;
-}
-async function prerenderRoute(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
+  return paths.map(p => p.replace(/\/\/+/g, '/').replace(/(.+)\/$/, '$1'))
+}
+async function prerenderData(
+  handler,
+  prerenderPath,
+  clientBuildDirectory,
+  reactRouterConfig,
+  viteConfig,
+  requestInit,
+) {
+  let normalizedPath =
+    `${reactRouterConfig.basename}${prerenderPath === '/' ? '/_root.data' : `${prerenderPath.replace(/\/$/, '')}.data`}`.replace(
+      /\/\/+/g,
+      '/',
+    )
+  let request = new Request(`http://localhost${normalizedPath}`, requestInit)
+  let response = await handler(request)
+  let data = await response.text()
+  validatePrerenderedResponse(response, data, 'Prerender', normalizedPath)
+  let outdir = path4.relative(process.cwd(), clientBuildDirectory)
+  let outfile = path4.join(outdir, ...normalizedPath.split('/'))
+  await fse.ensureDir(path4.dirname(outfile))
+  await fse.outputFile(outfile, data)
+  viteConfig.logger.info(
+    `Prerender: Generated ${import_picocolors3.default.bold(outfile)}`,
+  )
+  return data
+}
+async function prerenderRoute(
+  handler,
+  prerenderPath,
+  clientBuildDirectory,
+  reactRouterConfig,
+  viteConfig,
+  requestInit,
+) {
   let normalizedPath = `${reactRouterConfig.basename}${prerenderPath}/`.replace(
     /\/\/+/g,
-    "/"
-  );
-  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
-  let response = await handler(request);
-  let html = await response.text();
-  validatePrerenderedResponse(response, html, "Prerender", normalizedPath);
+    '/',
+  )
+  let request = new Request(`http://localhost${normalizedPath}`, requestInit)
+  let response = await handler(request)
+  let html = await response.text()
+  validatePrerenderedResponse(response, html, 'Prerender', normalizedPath)
   if (!reactRouterConfig.ssr) {
-    validatePrerenderedHtml(html, "Prerender");
-  }
-  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
-  let outfile = path4.join(outdir, ...normalizedPath.split("/"), "index.html");
-  await fse.ensureDir(path4.dirname(outfile));
-  await fse.outputFile(outfile, html);
-  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
-}
-async function prerenderResourceRoute(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
-  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath}/`.replace(/\/\/+/g, "/").replace(/\/$/g, "");
-  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
-  let response = await handler(request);
-  let text = await response.text();
-  validatePrerenderedResponse(response, text, "Prerender", normalizedPath);
-  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
-  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
-  await fse.ensureDir(path4.dirname(outfile));
-  await fse.outputFile(outfile, text);
-  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
-}
-async function prerenderManifest(build, clientBuildDirectory, reactRouterConfig, viteConfig) {
+    validatePrerenderedHtml(html, 'Prerender')
+  }
+  let outdir = path4.relative(process.cwd(), clientBuildDirectory)
+  let outfile = path4.join(outdir, ...normalizedPath.split('/'), 'index.html')
+  await fse.ensureDir(path4.dirname(outfile))
+  await fse.outputFile(outfile, html)
+  viteConfig.logger.info(
+    `Prerender: Generated ${import_picocolors3.default.bold(outfile)}`,
+  )
+}
+async function prerenderResourceRoute(
+  handler,
+  prerenderPath,
+  clientBuildDirectory,
+  reactRouterConfig,
+  viteConfig,
+  requestInit,
+) {
+  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath}/`
+    .replace(/\/\/+/g, '/')
+    .replace(/\/$/g, '')
+  let request = new Request(`http://localhost${normalizedPath}`, requestInit)
+  let response = await handler(request)
+  let text = await response.text()
+  validatePrerenderedResponse(response, text, 'Prerender', normalizedPath)
+  let outdir = path4.relative(process.cwd(), clientBuildDirectory)
+  let outfile = path4.join(outdir, ...normalizedPath.split('/'))
+  await fse.ensureDir(path4.dirname(outfile))
+  await fse.outputFile(outfile, text)
+  viteConfig.logger.info(
+    `Prerender: Generated ${import_picocolors3.default.bold(outfile)}`,
+  )
+}
+async function prerenderManifest(
+  build,
+  clientBuildDirectory,
+  reactRouterConfig,
+  viteConfig,
+) {
   let normalizedPath = `${reactRouterConfig.basename}/__manifest`.replace(
     /\/\/+/g,
-    "/"
-  );
-  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
-  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
-  await fse.ensureDir(path4.dirname(outfile));
-  let manifestData = JSON.stringify(build.assets.routes);
-  await fse.outputFile(outfile, manifestData);
-  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
+    '/',
+  )
+  let outdir = path4.relative(process.cwd(), clientBuildDirectory)
+  let outfile = path4.join(outdir, ...normalizedPath.split('/'))
+  await fse.ensureDir(path4.dirname(outfile))
+  let manifestData = JSON.stringify(build.assets.routes)
+  await fse.outputFile(outfile, manifestData)
+  viteConfig.logger.info(
+    `Prerender: Generated ${import_picocolors3.default.bold(outfile)}`,
+  )
 }
 function validatePrerenderedResponse(response, html, prefix, path5) {
   if (response.status !== 200) {
     throw new Error(
       `${prefix}: Received a ${response.status} status code from \`entry.server.tsx\` while prerendering the \`${path5}\` path.
-${html}`
-    );
+${html}`,
+    )
   }
 }
 function validatePrerenderedHtml(html, prefix) {
-  if (!html.includes("window.__reactRouterContext =") || !html.includes("window.__reactRouterRouteModules =")) {
+  if (
+    !html.includes('window.__reactRouterContext =') ||
+    !html.includes('window.__reactRouterRouteModules =')
+  ) {
     throw new Error(
-      `${prefix}: Did you forget to include <Scripts/> in your root route? Your pre-rendered HTML files cannot hydrate without \`<Scripts />\`.`
-    );
+      `${prefix}: Did you forget to include <Scripts/> in your root route? Your pre-rendered HTML files cannot hydrate without \`<Scripts />\`.`,
+    )
   }
 }
 function groupRoutesByParentId2(manifest) {
-  let routes = {};
-  Object.values(manifest).forEach((route) => {
+  let routes = {}
+  Object.values(manifest).forEach(route => {
     if (route) {
-      let parentId = route.parentId || "";
+      let parentId = route.parentId || ''
       if (!routes[parentId]) {
-        routes[parentId] = [];
+        routes[parentId] = []
       }
-      routes[parentId].push(route);
+      routes[parentId].push(route)
     }
-  });
-  return routes;
+  })
+  return routes
 }
-function createPrerenderRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
-  return (routesByParentId[parentId] || []).map((route) => {
+function createPrerenderRoutes(
+  manifest,
+  parentId = '',
+  routesByParentId = groupRoutesByParentId2(manifest),
+) {
+  return (routesByParentId[parentId] || []).map(route => {
     let commonRoute = {
       // Always include root due to default boundaries
-      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
+      hasErrorBoundary:
+        route.id === 'root' || route.module.ErrorBoundary != null,
       id: route.id,
       path: route.path,
       loader: route.module.loader ? () => null : void 0,
       action: void 0,
-      handle: route.module.handle
-    };
-    return route.index ? {
-      index: true,
-      ...commonRoute
-    } : {
-      caseSensitive: route.caseSensitive,
-      children: createPrerenderRoutes(manifest, route.id, routesByParentId),
-      ...commonRoute
-    };
-  });
+      handle: route.module.handle,
+    }
+    return route.index
+      ? {
+          index: true,
+          ...commonRoute,
+        }
+      : {
+          caseSensitive: route.caseSensitive,
+          children: createPrerenderRoutes(manifest, route.id, routesByParentId),
+          ...commonRoute,
+        }
+  })
 }
 // Annotate the CommonJS export names for ESM import in node:
-0 && (module.exports = {
-  reactRouter
-});
+0 &&
+  (module.exports = {
+    reactRouter,
+  })
